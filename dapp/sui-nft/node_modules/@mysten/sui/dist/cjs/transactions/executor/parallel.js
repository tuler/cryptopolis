"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var parallel_exports = {};
__export(parallel_exports, {
  ParallelTransactionExecutor: () => ParallelTransactionExecutor
});
module.exports = __toCommonJS(parallel_exports);
var import_bcs = require("@mysten/bcs");
var import_bcs2 = require("../../bcs/index.js");
var import_Transaction = require("../Transaction.js");
var import_caching = require("./caching.js");
var import_queue = require("./queue.js");
var import_serial = require("./serial.js");
var _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _getUsedObjects, getUsedObjects_fn, _execute, execute_fn, _getGasCoin, getGasCoin_fn, _refillCoinPool, refillCoinPool_fn;
const PARALLEL_EXECUTOR_DEFAULTS = {
  coinBatchSize: 20,
  initialCoinBalance: 200000000n,
  minimumCoinBalance: 50000000n,
  maxPoolSize: 50
};
class ParallelTransactionExecutor {
  constructor(options) {
    __privateAdd(this, _getUsedObjects);
    __privateAdd(this, _execute);
    __privateAdd(this, _getGasCoin);
    __privateAdd(this, _refillCoinPool);
    __privateAdd(this, _signer, void 0);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _coinBatchSize, void 0);
    __privateAdd(this, _initialCoinBalance, void 0);
    __privateAdd(this, _minimumCoinBalance, void 0);
    __privateAdd(this, _maxPoolSize, void 0);
    __privateAdd(this, _sourceCoins, void 0);
    __privateAdd(this, _coinPool, []);
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _objectIdQueues, /* @__PURE__ */ new Map());
    __privateAdd(this, _buildQueue, new import_queue.SerialQueue());
    __privateAdd(this, _executeQueue, void 0);
    __privateSet(this, _signer, options.signer);
    __privateSet(this, _client, options.client);
    __privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);
    __privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);
    __privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);
    __privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);
    __privateSet(this, _cache, new import_caching.CachingTransactionExecutor({
      client: options.client,
      cache: options.cache
    }));
    __privateSet(this, _executeQueue, new import_queue.ParallelQueue(__privateGet(this, _maxPoolSize)));
    __privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map((id) => [id, null])) : null);
  }
  resetCache() {
    return __privateGet(this, _cache).reset();
  }
  async executeTransaction(transaction) {
    const { promise, resolve, reject } = promiseWithResolvers();
    const usedObjects = await __privateMethod(this, _getUsedObjects, getUsedObjects_fn).call(this, transaction);
    const execute = () => {
      __privateGet(this, _executeQueue).runTask(() => {
        const promise2 = __privateMethod(this, _execute, execute_fn).call(this, transaction, usedObjects);
        return promise2.then(resolve, reject);
      });
    };
    const conflicts = /* @__PURE__ */ new Set();
    usedObjects.forEach((objectId) => {
      const queue = __privateGet(this, _objectIdQueues).get(objectId);
      if (queue) {
        conflicts.add(objectId);
        __privateGet(this, _objectIdQueues).get(objectId).push(() => {
          conflicts.delete(objectId);
          if (conflicts.size === 0) {
            execute();
          }
        });
      } else {
        __privateGet(this, _objectIdQueues).set(objectId, []);
      }
    });
    if (conflicts.size === 0) {
      execute();
    }
    return promise;
  }
}
_signer = new WeakMap();
_client = new WeakMap();
_coinBatchSize = new WeakMap();
_initialCoinBalance = new WeakMap();
_minimumCoinBalance = new WeakMap();
_maxPoolSize = new WeakMap();
_sourceCoins = new WeakMap();
_coinPool = new WeakMap();
_cache = new WeakMap();
_objectIdQueues = new WeakMap();
_buildQueue = new WeakMap();
_executeQueue = new WeakMap();
_getUsedObjects = new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      if (input.Object?.ImmOrOwnedObject?.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if (input.Object?.Receiving?.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet(this, _client) });
  return usedObjects;
};
_execute = new WeakSet();
execute_fn = async function(transaction, usedObjects) {
  let gasCoin;
  try {
    const bytes = await __privateGet(this, _buildQueue).runTask(async () => {
      gasCoin = await __privateMethod(this, _getGasCoin, getGasCoin_fn).call(this);
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());
      return __privateGet(this, _cache).buildTransaction({ transaction });
    });
    const { signature } = await __privateGet(this, _signer).signTransaction(bytes);
    const results = await __privateGet(this, _cache).executeTransaction({
      transaction: bytes,
      signature,
      options: {
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = import_bcs2.bcs.TransactionEffects.parse(effectsBytes);
    const gasResult = (0, import_serial.getGasCoinFromEffects)(effects);
    const gasUsed = effects.V2?.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      if (gasCoin.balance >= __privateGet(this, _minimumCoinBalance)) {
        __privateGet(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: gasCoin.balance - totalUsed
        });
      } else {
        if (!__privateGet(this, _sourceCoins)) {
          __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    return {
      digest: results.digest,
      effects: (0, import_bcs.toB64)(effectsBytes)
    };
  } catch (error) {
    if (gasCoin) {
      if (!__privateGet(this, _sourceCoins)) {
        __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateGet(this, _cache).cache.deleteObjects([...usedObjects]);
    throw error;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet(this, _objectIdQueues).delete(objectId);
      }
    });
  }
};
_getGasCoin = new WeakSet();
getGasCoin_fn = async function() {
  if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _executeQueue).activeTasks <= __privateGet(this, _maxPoolSize)) {
    await __privateMethod(this, _refillCoinPool, refillCoinPool_fn).call(this);
  }
  if (__privateGet(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet(this, _coinPool).shift();
  return coin;
};
_refillCoinPool = new WeakSet();
refillCoinPool_fn = async function() {
  const batchSize = Math.min(
    __privateGet(this, _coinBatchSize),
    __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _executeQueue).activeTasks) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new import_Transaction.Transaction();
  const address = __privateGet(this, _signer).toSuiAddress();
  txb.setSender(address);
  if (__privateGet(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id, ref] of __privateGet(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet(this, _client).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i = 0; i < amounts.length; i++) {
    coinResults.push(results[i]);
  }
  txb.transferObjects(coinResults, address);
  const result = await __privateGet(this, _client).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet(this, _signer),
    options: {
      showRawEffects: true
    }
  });
  const effects = import_bcs2.bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  effects.V2?.changedObjects.forEach(([id, { outputState }], i) => {
    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {
      return;
    }
    __privateGet(this, _coinPool).push({
      id,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet(this, _initialCoinBalance))
    });
  });
  if (!__privateGet(this, _sourceCoins)) {
    __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = (0, import_serial.getGasCoinFromEffects)(effects).ref;
  __privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet(this, _client).waitForTransaction({ digest: result.digest });
};
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, resolve, reject };
}
//# sourceMappingURL=parallel.js.map
