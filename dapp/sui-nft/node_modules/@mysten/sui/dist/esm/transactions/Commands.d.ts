/// <reference types="node" />
import type { Input } from 'valibot';
import { Argument } from './data/internal.js';
import type { CallArg, Command } from './data/internal.js';
import type { Transaction } from './Transaction.js';
export type TransactionArgument = Input<typeof Argument> | ((tx: Transaction) => Input<typeof Argument>);
export type TransactionInput = CallArg;
export declare enum UpgradePolicy {
    COMPATIBLE = 0,
    ADDITIVE = 128,
    DEP_ONLY = 192
}
type TransactionShape<T extends Command['$kind']> = {
    $kind: T;
} & {
    [K in T]: Extract<Command, {
        [K in T]: any;
    }>[T];
};
/**
 * Simple helpers used to construct transactions:
 */
export declare const Commands: {
    MoveCall(input: {
        package: string;
        module: string;
        function: string;
        arguments?: ({
            $kind: "GasCoin";
            GasCoin: true;
        } | {
            $kind: "Input";
            Input: number;
            type?: "pure" | undefined;
        } | {
            $kind: "Input";
            Input: number;
            type?: "object" | undefined;
        } | {
            $kind: "Result";
            Result: number;
        } | {
            $kind: "NestedResult";
            NestedResult: [number, number];
        })[] | undefined;
        typeArguments?: string[] | undefined;
    } | {
        target: string;
        arguments?: ({
            $kind: "GasCoin";
            GasCoin: true;
        } | {
            $kind: "Input";
            Input: number;
            type?: "pure" | undefined;
        } | {
            $kind: "Input";
            Input: number;
            type?: "object" | undefined;
        } | {
            $kind: "Result";
            Result: number;
        } | {
            $kind: "NestedResult";
            NestedResult: [number, number];
        })[] | undefined;
        typeArguments?: string[] | undefined;
    }): TransactionShape<'MoveCall'>;
    TransferObjects(objects: Input<typeof Argument>[], address: Input<typeof Argument>): TransactionShape<'TransferObjects'>;
    SplitCoins(coin: Input<typeof Argument>, amounts: Input<typeof Argument>[]): TransactionShape<'SplitCoins'>;
    MergeCoins(destination: Input<typeof Argument>, sources: Input<typeof Argument>[]): TransactionShape<'MergeCoins'>;
    Publish({ modules, dependencies, }: {
        modules: number[][] | string[];
        dependencies: string[];
    }): TransactionShape<'Publish'>;
    Upgrade({ modules, dependencies, package: packageId, ticket, }: {
        modules: number[][] | string[];
        dependencies: string[];
        package: string;
        ticket: Input<typeof Argument>;
    }): TransactionShape<'Upgrade'>;
    MakeMoveVec({ type, elements, }: {
        type?: string | undefined;
        elements: Input<typeof Argument>[];
    }): TransactionShape<'MakeMoveVec'>;
    Intent({ name, inputs, data, }: {
        name: string;
        inputs?: Record<string, {
            GasCoin: true;
        } | {
            Input: number;
            type?: "object" | "pure" | undefined;
        } | {
            Result: number;
        } | {
            NestedResult: [number, number];
        } | ({
            GasCoin: true;
        } | {
            Input: number;
            type?: "object" | "pure" | undefined;
        } | {
            Result: number;
        } | {
            NestedResult: [number, number];
        })[]> | undefined;
        data?: Record<string, unknown> | undefined;
    }): TransactionShape<'$Intent'>;
};
export {};
