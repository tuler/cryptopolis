{
  "version": 3,
  "sources": ["../../../src/transactions/Transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport type { Input } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<Input<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<Input<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n\tconst baseResult = { $kind: 'Result' as const, Result: index };\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tNestedResult: [index, resultIndex],\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[] = [];\n\t#buildPlugins: TransactionPlugin[] = [];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromB64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\treturn newTransaction;\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: Input<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#data.addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#data.addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tthis.#data = new TransactionDataBuilder();\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } {\n\t\tif (typeof value === 'function') {\n\t\t\treturn this.object(value(this));\n\t\t}\n\n\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\n\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t// Upgrade shared object inputs to mutable if needed:\n\t\tif (inserted?.Object?.SharedObject && typeof value === 'object' && value.Object?.SharedObject) {\n\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t}\n\n\t\treturn inserted\n\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t: this.#data.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: value,\n\t\t\t  );\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction */\n\tadd(command: Command | ((tx: Transaction) => TransactionResult)): TransactionResult {\n\t\tif (typeof command === 'function') {\n\t\t\treturn command(this);\n\t\t}\n\n\t\tconst index = this.#data.commands.push(command);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\treturn parse(Argument, arg(this));\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\treturn JSON.stringify(\n\t\t\tparse(SerializedTransactionDataV2, this.#data.snapshot()),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent && options.supportedIntents) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
