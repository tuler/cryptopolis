{"version":3,"file":"thread-chunk.js","sources":["../../src/commands/generate-persisted/thread.ts"],"sourcesContent":["import ts from 'typescript';\nimport { parse, print } from '@0no-co/graphql.web';\n\nimport type { FragmentDefinitionNode } from '@0no-co/graphql.web';\nimport type { GraphQLSPConfig } from '@gql.tada/internal';\nimport { getSchemaNamesFromConfig } from '@gql.tada/internal';\n\nimport {\n  findAllPersistedCallExpressions,\n  getDocumentReferenceFromTypeQuery,\n  getDocumentReferenceFromDocumentNode,\n  unrollTadaFragments,\n} from '@0no-co/graphqlsp/api';\n\nimport { programFactory } from '../../ts';\nimport { expose } from '../../threads';\n\nimport type { PersistedSignal, PersistedWarning, PersistedDocument } from './types';\n\nexport interface PersistedParams {\n  disableNormalization: boolean;\n  rootPath: string;\n  configPath: string;\n  pluginConfig: GraphQLSPConfig;\n}\n\nasync function* _runPersisted(params: PersistedParams): AsyncIterableIterator<PersistedSignal> {\n  const schemaNames = getSchemaNamesFromConfig(params.pluginConfig);\n  const factory = programFactory(params);\n\n  const externalFiles = factory.createExternalFiles();\n  if (externalFiles.length) {\n    yield { kind: 'EXTERNAL_WARNING' };\n    await factory.addVirtualFiles(externalFiles);\n  }\n\n  const container = factory.build();\n  const pluginInfo = container.buildPluginInfo(params.pluginConfig);\n  const sourceFiles = container.getSourceFiles();\n\n  yield {\n    kind: 'FILE_COUNT',\n    fileCount: sourceFiles.length,\n  };\n\n  for (const sourceFile of sourceFiles) {\n    let filePath = sourceFile.fileName;\n    const documents: PersistedDocument[] = [];\n    const warnings: PersistedWarning[] = [];\n\n    const calls = findAllPersistedCallExpressions(sourceFile, pluginInfo);\n    for (const call of calls) {\n      const position = container.getSourcePosition(sourceFile, call.node.getStart());\n      filePath = position.fileName;\n\n      if (!schemaNames.has(call.schema)) {\n        warnings.push({\n          message: call.schema\n            ? `The '${call.schema}' schema is not in the configuration but was referenced by \"graphql.persisted\".`\n            : schemaNames.size > 1\n              ? 'The document is not for a known schema. Have you re-generated the output file?'\n              : 'Multiple schemas are configured, but the document is not for a specific schema.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const hashArg = call.node.arguments[0];\n      const docArg = call.node.arguments[1];\n      const typeQuery = call.node.typeArguments && call.node.typeArguments[0];\n      if (!hashArg || !ts.isStringLiteral(hashArg)) {\n        warnings.push({\n          message:\n            '\"graphql.persisted\" must be called with a string literal as the first argument.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      } else if (!docArg && !typeQuery) {\n        warnings.push({\n          message:\n            '\"graphql.persisted\" is missing a document.\\n' +\n            'This may be passed as a generic such as `graphql.persisted<typeof document>` or as the second argument.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      let foundNode: ts.CallExpression | null = null;\n      let referencingNode: ts.Node = call.node;\n      if (docArg && (ts.isCallExpression(docArg) || ts.isIdentifier(docArg))) {\n        const result = getDocumentReferenceFromDocumentNode(\n          docArg,\n          sourceFile.fileName,\n          pluginInfo\n        );\n        foundNode = result.node;\n        referencingNode = docArg;\n      } else if (typeQuery && ts.isTypeQueryNode(typeQuery)) {\n        const result = getDocumentReferenceFromTypeQuery(\n          typeQuery,\n          sourceFile.fileName,\n          pluginInfo\n        );\n        foundNode = result.node;\n        referencingNode = typeQuery;\n      }\n\n      if (!foundNode) {\n        warnings.push({\n          message:\n            `Could not find reference for \"${referencingNode.getText()}\".\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      if (\n        !foundNode ||\n        !ts.isCallExpression(foundNode) ||\n        (!ts.isNoSubstitutionTemplateLiteral(foundNode.arguments[0]) &&\n          !ts.isStringLiteral(foundNode.arguments[0]))\n      ) {\n        warnings.push({\n          message:\n            `The referenced document of \"${referencingNode.getText()}\" contains no document string literal.\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const fragmentDefs: FragmentDefinitionNode[] = [];\n      const operation = foundNode.arguments[0].getText().slice(1, -1);\n      if (foundNode.arguments[1] && ts.isArrayLiteralExpression(foundNode.arguments[1])) {\n        unrollTadaFragments(\n          foundNode.arguments[1],\n          fragmentDefs,\n          container.buildPluginInfo(params.pluginConfig)\n        );\n      }\n\n      const seen = new Set<string>();\n      let document: string;\n      if (params.disableNormalization) {\n        document = operation;\n      } else {\n        try {\n          document = print(parse(operation));\n        } catch (_error) {\n          warnings.push({\n            message:\n              `The referenced document of \"${referencingNode.getText()}\" could not be parsed.\\n` +\n              'Run `check` to see specific validation errors.',\n            file: position.fileName,\n            line: position.line,\n            col: position.col,\n          });\n          continue;\n        }\n      }\n\n      // NOTE: Update graphqlsp not to pre-parse fragments, which also swallows errors\n      for (const fragmentDef of fragmentDefs) {\n        const printedFragmentDef = print(fragmentDef);\n        if (!seen.has(printedFragmentDef)) {\n          document += '\\n\\n' + print(fragmentDef);\n          seen.add(printedFragmentDef);\n        }\n      }\n\n      documents.push({\n        schemaName: call.schema,\n        hashKey: hashArg.getText().slice(1, -1),\n        document,\n      });\n    }\n\n    yield {\n      kind: 'FILE_PERSISTED',\n      filePath,\n      documents,\n      warnings,\n    };\n  }\n}\n\nexport const runPersisted = expose(_runPersisted);\n"],"names":["runPersisted","expose","async","_runPersisted","params","schemaNames","getSchemaNamesFromConfig","pluginConfig","factory","programFactory","externalFiles","createExternalFiles","length","kind","addVirtualFiles","container","build","pluginInfo","buildPluginInfo","sourceFiles","getSourceFiles","fileCount","sourceFile","filePath","fileName","documents","warnings","calls","findAllPersistedCallExpressions","call","position","getSourcePosition","node","getStart","has","schema","push","message","size","file","line","col","hashArg","arguments","docArg","typeQuery","typeArguments","ts","isStringLiteral","foundNode","referencingNode","isCallExpression","isIdentifier","getDocumentReferenceFromDocumentNode","isTypeQueryNode","getDocumentReferenceFromTypeQuery","getText","isNoSubstitutionTemplateLiteral","fragmentDefs","operation","slice","isArrayLiteralExpression","unrollTadaFragments","seen","Set","document","disableNormalization","print","parse","_error","fragmentDef","printedFragmentDef","add","schemaName","hashKey"],"mappings":"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"}