{"version":3,"file":"vue-chunk.js","sources":["../../src/ts/transformers/vue.ts"],"sourcesContent":["import ts from 'typescript';\nimport type { VirtualCode } from '@vue/language-core';\nimport * as vueCompilerDOM from '@vue/compiler-dom';\nimport * as vue from '@vue/language-core';\nimport { parse } from '@vue/language-core';\n\nconst useVueFilePlugin: vue.VueLanguagePlugin = (_ctx) => {\n  return {\n    version: 2,\n\n    parseSFC(_fileName, content) {\n      return parse(content);\n    },\n\n    updateSFC(sfc, change) {\n      const blocks = [\n        sfc.descriptor.template,\n        sfc.descriptor.script,\n        sfc.descriptor.scriptSetup,\n        ...sfc.descriptor.styles,\n        ...sfc.descriptor.customBlocks,\n      ].filter((block): block is NonNullable<typeof block> => !!block);\n\n      const hitBlock = blocks.find(\n        (block) => change.start >= block.loc.start.offset && change.end <= block.loc.end.offset\n      );\n      if (!hitBlock) {\n        return;\n      }\n\n      const oldContent = hitBlock.content;\n      const newContent = (hitBlock.content =\n        hitBlock.content.substring(0, change.start - hitBlock.loc.start.offset) +\n        change.newText +\n        hitBlock.content.substring(change.end - hitBlock.loc.start.offset));\n\n      // #3449\n      const endTagRegex = new RegExp(`</\\\\s*${hitBlock.type}\\\\s*>`);\n      const insertedEndTag = !!oldContent.match(endTagRegex) !== !!newContent.match(endTagRegex);\n      if (insertedEndTag) {\n        return;\n      }\n\n      const lengthDiff = change.newText.length - (change.end - change.start);\n\n      for (const block of blocks) {\n        if (block.loc.start.offset > change.end) {\n          block.loc.start.offset += lengthDiff;\n        }\n        if (block.loc.end.offset >= change.end) {\n          block.loc.end.offset += lengthDiff;\n        }\n      }\n\n      return sfc;\n    },\n  };\n};\n\nfunction* forEachEmbeddedCode(virtualCode: VirtualCode) {\n  yield virtualCode;\n  if (virtualCode.embeddedCodes) {\n    for (const embeddedCode of virtualCode.embeddedCodes) {\n      yield* forEachEmbeddedCode(embeddedCode);\n    }\n  }\n}\n\nlet VueVirtualCode: typeof vue.VueVirtualCode | undefined;\nif ('VueVirtualCode' in vue) {\n  VueVirtualCode = vue.VueVirtualCode;\n} else if ('VueGeneratedCode' in vue) {\n  VueVirtualCode = (vue as any).VueGeneratedCode;\n}\n\nlet getBasePlugins: typeof vue.getBasePlugins | undefined;\nif ('getBasePlugins' in vue) {\n  getBasePlugins = vue.getBasePlugins;\n} else if ('getDefaultVueLanguagePlugins' in vue) {\n  getBasePlugins = (vue as any).getDefaultVueLanguagePlugins;\n}\n\nconst vueCompilerOptions = vue.resolveVueCompilerOptions({});\n\nlet plugins: ReturnType<typeof vue.getBasePlugins> | undefined;\n\nexport const transform = (sourceFile: ts.SourceFile): VirtualCode | undefined => {\n  if (!VueVirtualCode || !getBasePlugins) {\n    return undefined;\n  } else if (!plugins) {\n    const pluginContext = {\n      modules: {\n        typescript: ts,\n        '@vue/compiler-dom': vueCompilerDOM,\n      },\n      compilerOptions: {},\n      globalTypesHolder: undefined,\n      vueCompilerOptions,\n    };\n    plugins = getBasePlugins(pluginContext);\n    const vueSfcPlugin = useVueFilePlugin(pluginContext);\n    plugins.push(vueSfcPlugin);\n  }\n\n  const snapshot = ts.ScriptSnapshot.fromString(sourceFile.getFullText());\n  const root = new VueVirtualCode(\n    sourceFile.fileName,\n    'vue',\n    snapshot,\n    vueCompilerOptions,\n    plugins,\n    ...([ts, false] as any as [typeof ts])\n  );\n  for (const code of forEachEmbeddedCode(root)) if (code.id.startsWith('script_')) return code;\n};\n"],"names":["forEachEmbeddedCode","virtualCode","embeddedCodes","embeddedCode","VueVirtualCode","vue","VueGeneratedCode","getBasePlugins","getDefaultVueLanguagePlugins","vueCompilerOptions","resolveVueCompilerOptions","plugins","sourceFile","modules","typescript","ts","vueCompilerDOM","compilerOptions","globalTypesHolder","undefined","push","version","parseSFC","_fileName","content","parse","updateSFC","sfc","change","blocks","descriptor","template","script","scriptSetup","styles","customBlocks","filter","block","hitBlock","find","start","loc","offset","end","oldContent","newContent","substring","newText","endTagRegex","RegExp","type","match","lengthDiff","length","snapshot","ScriptSnapshot","fromString","getFullText","root","fileName","code","id","startsWith"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA,UAAUA,oBAAoBC;QACtBA;EACN,IAAIA,EAAYC;IACd,KAAK,IAAMC,KAAgBF,EAAYC;aAC9BF,oBAAoBG;;;AAGjC;;AAEA,IAAIC;;AACJ,IAAI,oBAAoBC;EACtBD,IAAiBC,EAAID;OAChB,IAAI,sBAAsBC;EAC/BD,IAAkBC,EAAYC;;;AAGhC,IAAIC;;AACJ,IAAI,oBAAoBF;EACtBE,IAAiBF,EAAIE;OAChB,IAAI,kCAAkCF;EAC3CE,IAAkBF,EAAYG;;;AAGhC,IAAMC,IAAqBJ,EAAIK,0BAA0B,CAAA;;AAEzD,IAAIC;;oBAEsBC;EACxB,KAAKR,MAAmBG;IACtB;SACK,KAAKI,GAAS;KAUnBA,IAAUJ,EATY;MACpBM,SAAS;QACPC,YAAYC;QACZ,qBAAqBC;;MAEvBC,iBAAiB,CAAE;MACnBC,wBAAmBC;MACnBV;QAIMW,KA9FH;MACLC,SAAS;MAETC,UAAQA,CAACC,GAAWC,MACXC,EAAAA,MAAMD;MAGfE,SAAAA,CAAUC,GAAKC;QACb,IAAMC,IAAS,EACbF,EAAIG,WAAWC,UACfJ,EAAIG,WAAWE,QACfL,EAAIG,WAAWG,gBACZN,EAAIG,WAAWI,WACfP,EAAIG,WAAWK,eAClBC,QAAQC,OAAgDA;QAE1D,IAAMC,IAAWT,EAAOU,MACrBF,KAAUT,EAAOY,SAASH,EAAMI,IAAID,MAAME,UAAUd,EAAOe,OAAON,EAAMI,IAAIE,IAAID;QAEnF,KAAKJ;UACH;;QAGF,IAAMM,IAAaN,EAASd;QAC5B,IAAMqB,IAAcP,EAASd,UAC3Bc,EAASd,QAAQsB,UAAU,GAAGlB,EAAOY,QAAQF,EAASG,IAAID,MAAME,UAChEd,EAAOmB,UACPT,EAASd,QAAQsB,UAAUlB,EAAOe,MAAML,EAASG,IAAID,MAAME;QAG7D,IAAMM,IAAc,IAAIC,OAAQ,SAAQX,EAASY;QAEjD,MADyBN,EAAWO,MAAMH,QAAmBH,EAAWM,MAAMH;UAE5E;;QAGF,IAAMI,IAAaxB,EAAOmB,QAAQM,UAAUzB,EAAOe,MAAMf,EAAOY;QAEhE,KAAK,IAAMH,KAASR,GAAQ;UAC1B,IAAIQ,EAAMI,IAAID,MAAME,SAASd,EAAOe;YAClCN,EAAMI,IAAID,MAAME,UAAUU;;UAE5B,IAAIf,EAAMI,IAAIE,IAAID,UAAUd,EAAOe;YACjCN,EAAMI,IAAIE,IAAID,UAAUU;;AAE5B;QAEA,OAAOzB;AACT;;AA+CF;EAEA,IAAM2B,IAAWvC,EAAGwC,eAAeC,WAAW5C,EAAW6C;EACzD,IAAMC,IAAO,IAAItD,EACfQ,EAAW+C,UACX,OACAL,GACA7C,GACAE,MACI,EAACI,IAAI;EAEX,KAAK,IAAM6C,KAAQ5D,oBAAoB0D;IAAO,IAAIE,EAAKC,GAAGC,WAAW;MAAY,OAAOF;;;AAAI"}