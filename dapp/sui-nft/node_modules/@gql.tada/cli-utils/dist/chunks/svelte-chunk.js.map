{"version":3,"file":"svelte-chunk.js","sources":["../../../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js","../../../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.11/node_modules/vscode-languageserver-textdocument/lib/esm/main.js","../../src/ts/transformers/svelte.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (let change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            let startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        let ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        let ch = text.charCodeAt(i);\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","import ts from 'typescript';\nimport type { CodeMapping, VirtualCode } from '@vue/language-core';\nimport { decode } from '@jridgewell/sourcemap-codec';\nimport { svelte2tsx } from 'svelte2tsx';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\n\n// See: https://github.com/johnsoncodehk/language-tools/blob/volar2/packages/language-server/src/languagePlugin.ts\nexport const transform = (sourceFile: ts.SourceFile): VirtualCode | undefined => {\n  const text = sourceFile.getFullText();\n\n  let tsx: ReturnType<typeof svelte2tsx>;\n\n  try {\n    tsx = svelte2tsx(text, {\n      filename: sourceFile.fileName,\n      isTsFile: true,\n      emitOnTemplateError: true,\n      mode: 'ts',\n    });\n  } catch (error) {\n    return;\n  }\n\n  const v3Mappings = decode(tsx.map.mappings);\n  const document = TextDocument.create('', 'svelte', 0, text);\n  const generateDocument = TextDocument.create('', 'typescript', 0, tsx.code);\n  const mappings: CodeMapping[] = [];\n\n  let current:\n    | {\n        genOffset: number;\n        sourceOffset: number;\n      }\n    | undefined;\n\n  for (let genLine = 0; genLine < v3Mappings.length; genLine++) {\n    for (const segment of v3Mappings[genLine]) {\n      const genCharacter = segment[0];\n      const genOffset = generateDocument.offsetAt({ line: genLine, character: genCharacter });\n      if (current) {\n        let length = genOffset - current.genOffset;\n        const sourceText = text.substring(current.sourceOffset, current.sourceOffset + length);\n        const genText = tsx.code.substring(current.genOffset, current.genOffset + length);\n        if (sourceText !== genText) {\n          length = 0;\n          for (let i = 0; i < genOffset - current.genOffset; i++) {\n            if (sourceText[i] === genText[i]) {\n              length = i + 1;\n            } else {\n              break;\n            }\n          }\n        }\n        if (length > 0) {\n          const lastMapping = mappings.length ? mappings[mappings.length - 1] : undefined;\n          if (\n            lastMapping &&\n            lastMapping.generatedOffsets[0] + lastMapping.lengths[0] === current.genOffset &&\n            lastMapping.sourceOffsets[0] + lastMapping.lengths[0] === current.sourceOffset\n          ) {\n            lastMapping.lengths[0] += length;\n          } else {\n            mappings.push({\n              sourceOffsets: [current.sourceOffset],\n              generatedOffsets: [current.genOffset],\n              lengths: [length],\n              data: {\n                verification: true,\n                completion: true,\n                semantic: true,\n                navigation: true,\n                structure: false,\n                format: false,\n              },\n            });\n          }\n        }\n        current = undefined;\n      }\n      if (segment[2] !== undefined && segment[3] !== undefined) {\n        const sourceOffset = document.offsetAt({ line: segment[2], character: segment[3] });\n        current = {\n          genOffset,\n          sourceOffset,\n        };\n      }\n    }\n  }\n\n  return {\n    id: 'ts',\n    languageId: 'typescript',\n    snapshot: ts.ScriptSnapshot.fromString(tsx.code),\n    mappings: mappings,\n    embeddedCodes: [],\n  } satisfies VirtualCode;\n};\n"],"names":["exports","comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInt","i","length","c","TextDecoder","Buffer","decode","buf","from","buffer","byteOffset","byteLength","toString","out","String","fromCharCode","mappings","state","Int32Array","decoded","index","semi","indexOf","line","sorted","lastCol","seg","decodeInteger","col","hasMoreVlq","push","sort","idx","j","value","shift","integer","pos","shouldNegate","sortComparator","a","b","encode","bufLength","subLength","sub","subarray","_i3","td","segment","copyWithin","encodeInteger","factory","FullTextDocument","constructor","uri","languageId","version","content","this","_uri","_languageId","_version","_content","_lineOffsets","undefined","getText","range","start","offsetAt","end","substring","update","changes","change","isIncremental","getWellformedRange","startOffset","endOffset","text","startLine","Math","max","endLine","lineOffsets","addedLineOffsets","computeLineOffsets","len","splice","slice","concat","diff","isFull","Error","getLineOffsets","positionAt","offset","min","low","high","character","mid","floor","position","lineOffset","lineCount","event","candidate","rangeLength","TextDocument","create","document","applyEdits","edits","sortedEdits","mergeSort","map","getWellformedEdit","lastModifiedOffset","spans","e","newText","substr","join","data","compare","p","left","right","leftIdx","rightIdx","isAtLineStart","textOffset","result","ch","textEdit","sourceFile","getFullText","tsx","svelte2tsx","filename","fileName","isTsFile","emitOnTemplateError","mode","error","v3Mappings","generateDocument","code","current","genLine","genOffset","sourceText","sourceOffset","genText","lastMapping","generatedOffsets","lengths","sourceOffsets","verification","completion","semantic","navigation","structure","format","id","snapshot","ts","ScriptSnapshot","fromString","embeddedCodes"],"mappings":"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","x_google_ignoreList":[0,1]}