{"version":3,"file":"index-chunk.mjs","sources":["../../src/ts/utils.ts","../../src/ts/vendor/typescript-vfs.ts","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/binarySearch.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/track.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/types.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/index.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/binarySearch.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/translateOffset.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/sourceMap.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/buildMappings.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/buildStacks.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/index.js","../../src/ts/mapping.ts","../../src/ts/container.ts","../../src/ts/transformers/index.ts","../../src/ts/factory.ts","../../src/threads/index.ts"],"sourcesContent":["import type ts from 'typescript';\n\nexport interface SourcePosition {\n  fileName: string;\n  line: number;\n  col: number;\n  endLine: number | undefined;\n  endColumn: number | undefined;\n}\n\nexport const spanToFilePosition = (\n  file: ts.SourceFile,\n  span: ts.TextSpan | number\n): SourcePosition => {\n  const output: SourcePosition = {\n    fileName: file.fileName,\n    line: 1,\n    col: 1,\n    endLine: undefined,\n    endColumn: undefined,\n  };\n  let lineAndChar = file.getLineAndCharacterOfPosition(\n    typeof span === 'number' ? span : span.start\n  );\n  output.line = lineAndChar.line + 1;\n  output.col = lineAndChar.character + 1;\n  if (typeof span !== 'number' && span.length > 1) {\n    lineAndChar = file.getLineAndCharacterOfPosition(span.start + span.length - 1);\n    output.endLine = lineAndChar.line + 1;\n    output.endColumn = lineAndChar.character + 1;\n  }\n  return output;\n};\n","/**!\n * The MIT License (MIT)\n * Copyright (c) Microsoft Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n * associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @see {@link https://github.com/microsoft/TypeScript-Website/blob/7f1c6e0577a0df9f945530a876ec87145a8b1fee/packages/typescript-vfs/src/index.ts}\n */\n\nimport type {\n  System,\n  CompilerOptions,\n  CustomTransformers,\n  LanguageServiceHost,\n  CompilerHost,\n  SourceFile,\n} from 'typescript';\n\nimport * as path from 'node:path';\nimport * as fs from 'node:fs';\n\ntype TS = typeof import('typescript');\n\nexport interface VirtualTypeScriptEnvironment {\n  sys: System;\n  languageService: import('typescript').LanguageService;\n  getSourceFile: (fileName: string) => import('typescript').SourceFile | undefined;\n  createFile: (fileName: string, content: string) => void;\n  updateFile: (\n    fileName: string,\n    content: string,\n    replaceTextSpan?: import('typescript').TextSpan\n  ) => void;\n}\n\n/**\n * Makes a virtual copy of the TypeScript environment. This is the main API you want to be using with\n * `@typescript/vfs`. A lot of the other exposed functions are used by this function to get set up.\n *\n * @param sys - an object which conforms to the TS Sys (a shim over read/write access to the fs)\n * @param rootFiles - a list of files which are considered inside the project\n * @param ts - a copy of the TypeScript module\n * @param compilerOptions - the options for this compiler run\n * @param customTransformers - custom transformers for this compiler run\n */\nexport function createVirtualTypeScriptEnvironment(\n  sys: System,\n  rootFiles: string[],\n  ts: TS,\n  compilerOptions: CompilerOptions = {},\n  customTransformers?: CustomTransformers\n): VirtualTypeScriptEnvironment {\n  const mergedCompilerOpts = { ...defaultCompilerOptions(ts), ...compilerOptions };\n\n  const { languageServiceHost, updateFile } = createVirtualLanguageServiceHost(\n    sys,\n    rootFiles,\n    mergedCompilerOpts,\n    ts,\n    customTransformers\n  );\n  const languageService = ts.createLanguageService(languageServiceHost);\n  const diagnostics = languageService.getCompilerOptionsDiagnostics();\n\n  if (diagnostics.length) {\n    const compilerHost = createVirtualCompilerHost(sys, compilerOptions, ts);\n    throw new Error(ts.formatDiagnostics(diagnostics, compilerHost.compilerHost));\n  }\n\n  return {\n    // @ts-ignore\n    name: 'vfs',\n    sys,\n    languageService,\n    getSourceFile: (fileName) => languageService.getProgram()?.getSourceFile(fileName),\n\n    createFile: (fileName, content) => {\n      updateFile(ts.createSourceFile(fileName, content, mergedCompilerOpts.target!, false));\n    },\n    updateFile: (fileName, content, optPrevTextSpan) => {\n      const prevSourceFile = languageService.getProgram()!.getSourceFile(fileName);\n      if (!prevSourceFile) {\n        throw new Error('Did not find a source file for ' + fileName);\n      }\n      const prevFullContents = prevSourceFile.text;\n\n      // TODO: Validate if the default text span has a fencepost error?\n      const prevTextSpan = optPrevTextSpan ?? ts.createTextSpan(0, prevFullContents.length);\n      const newText =\n        prevFullContents.slice(0, prevTextSpan.start) +\n        content +\n        prevFullContents.slice(prevTextSpan.start + prevTextSpan.length);\n      const newSourceFile = ts.updateSourceFile(prevSourceFile, newText, {\n        span: prevTextSpan,\n        newLength: content.length,\n      });\n\n      updateFile(newSourceFile);\n    },\n  };\n}\n\n// TODO: This could be replaced by grabbing: https://github.com/microsoft/TypeScript/blob/main/src/lib/libs.json\n// and then using that to generate the list of files from the server, but it is not included in the npm package\n\n/**\n * Grab the list of lib files for a particular target, will return a bit more than necessary (by including\n * the dom) but that's OK, we're really working with the constraint that you can't get a list of files\n * when running in a browser.\n *\n * @param target - The compiler settings target baseline\n * @param ts - A copy of the TypeScript module\n */\nexport const knownLibFilesForCompilerOptions = (compilerOptions: CompilerOptions, ts: TS) => {\n  const target = compilerOptions.target || ts.ScriptTarget.ES5;\n  const lib = compilerOptions.lib || [];\n\n  // Note that this will include files which can't be found for particular versions of TS\n  // TODO: Replace this with some sort of API call if https://github.com/microsoft/TypeScript/pull/54011\n  // or similar is merged.\n  const files = [\n    'lib.d.ts',\n    'lib.decorators.d.ts',\n    'lib.decorators.legacy.d.ts',\n    'lib.dom.d.ts',\n    'lib.dom.iterable.d.ts',\n    'lib.webworker.d.ts',\n    'lib.webworker.importscripts.d.ts',\n    'lib.webworker.iterable.d.ts',\n    'lib.scripthost.d.ts',\n    'lib.es5.d.ts',\n    'lib.es6.d.ts',\n    'lib.es2015.collection.d.ts',\n    'lib.es2015.core.d.ts',\n    'lib.es2015.d.ts',\n    'lib.es2015.generator.d.ts',\n    'lib.es2015.iterable.d.ts',\n    'lib.es2015.promise.d.ts',\n    'lib.es2015.proxy.d.ts',\n    'lib.es2015.reflect.d.ts',\n    'lib.es2015.symbol.d.ts',\n    'lib.es2015.symbol.wellknown.d.ts',\n    'lib.es2016.array.include.d.ts',\n    'lib.es2016.d.ts',\n    'lib.es2016.full.d.ts',\n    'lib.es2017.d.ts',\n    'lib.es2017.date.d.ts',\n    'lib.es2017.full.d.ts',\n    'lib.es2017.intl.d.ts',\n    'lib.es2017.object.d.ts',\n    'lib.es2017.sharedmemory.d.ts',\n    'lib.es2017.string.d.ts',\n    'lib.es2017.typedarrays.d.ts',\n    'lib.es2018.asyncgenerator.d.ts',\n    'lib.es2018.asynciterable.d.ts',\n    'lib.es2018.d.ts',\n    'lib.es2018.full.d.ts',\n    'lib.es2018.intl.d.ts',\n    'lib.es2018.promise.d.ts',\n    'lib.es2018.regexp.d.ts',\n    'lib.es2019.array.d.ts',\n    'lib.es2019.d.ts',\n    'lib.es2019.full.d.ts',\n    'lib.es2019.intl.d.ts',\n    'lib.es2019.object.d.ts',\n    'lib.es2019.string.d.ts',\n    'lib.es2019.symbol.d.ts',\n    'lib.es2020.bigint.d.ts',\n    'lib.es2020.d.ts',\n    'lib.es2020.date.d.ts',\n    'lib.es2020.full.d.ts',\n    'lib.es2020.intl.d.ts',\n    'lib.es2020.number.d.ts',\n    'lib.es2020.promise.d.ts',\n    'lib.es2020.sharedmemory.d.ts',\n    'lib.es2020.string.d.ts',\n    'lib.es2020.symbol.wellknown.d.ts',\n    'lib.es2021.d.ts',\n    'lib.es2021.full.d.ts',\n    'lib.es2021.intl.d.ts',\n    'lib.es2021.promise.d.ts',\n    'lib.es2021.string.d.ts',\n    'lib.es2021.weakref.d.ts',\n    'lib.es2022.array.d.ts',\n    'lib.es2022.d.ts',\n    'lib.es2022.error.d.ts',\n    'lib.es2022.full.d.ts',\n    'lib.es2022.intl.d.ts',\n    'lib.es2022.object.d.ts',\n    'lib.es2022.regexp.d.ts',\n    'lib.es2022.sharedmemory.d.ts',\n    'lib.es2022.string.d.ts',\n    'lib.es2023.array.d.ts',\n    'lib.es2023.collection.d.ts',\n    'lib.es2023.d.ts',\n    'lib.es2023.full.d.ts',\n    'lib.esnext.array.d.ts',\n    'lib.esnext.asynciterable.d.ts',\n    'lib.esnext.bigint.d.ts',\n    'lib.esnext.d.ts',\n    'lib.esnext.decorators.d.ts',\n    'lib.esnext.disposable.d.ts',\n    'lib.esnext.full.d.ts',\n    'lib.esnext.intl.d.ts',\n    'lib.esnext.promise.d.ts',\n    'lib.esnext.string.d.ts',\n    'lib.esnext.symbol.d.ts',\n    'lib.esnext.weakref.d.ts',\n  ];\n\n  const targetToCut = ts.ScriptTarget[target];\n  const matches = files.filter((f) => f.startsWith(`lib.${targetToCut.toLowerCase()}`));\n  const targetCutIndex = files.indexOf(matches.pop()!);\n\n  const getMax = (array: number[]) =>\n    array && array.length\n      ? array.reduce((max, current) => (current > max ? current : max))\n      : undefined;\n\n  // Find the index for everything in\n  const indexesForCutting = lib.map((lib) => {\n    const matches = files.filter((f) => f.startsWith(`lib.${lib.toLowerCase()}`));\n    if (matches.length === 0) return 0;\n\n    const cutIndex = files.indexOf(matches.pop()!);\n    return cutIndex;\n  });\n\n  const libCutIndex = getMax(indexesForCutting) || 0;\n\n  const finalCutIndex = Math.max(targetCutIndex, libCutIndex);\n  return files.slice(0, finalCutIndex + 1);\n};\n\n/**\n * Sets up a Map with lib contents by grabbing the necessary files from\n * the local copy of typescript via the file system.\n *\n * The first two args are un-used, but kept around so as to not cause a\n * semver major bump for no gain to module users.\n */\nexport const createDefaultMapFromNodeModules = (\n  _compilerOptions: CompilerOptions,\n  _ts?: typeof import('typescript'),\n  tsLibDirectory?: string\n) => {\n  const getLib = (name: string) => {\n    const lib = tsLibDirectory || path.dirname(require.resolve('typescript'));\n    return fs.readFileSync(path.join(lib, name), 'utf8');\n  };\n\n  const libFiles = fs.readdirSync(tsLibDirectory || path.dirname(require.resolve('typescript')));\n  const knownLibFiles = libFiles.filter((f) => f.startsWith('lib.') && f.endsWith('.d.ts'));\n\n  const fsMap = new Map<string, string>();\n  knownLibFiles.forEach((lib) => {\n    fsMap.set('/' + lib, getLib(lib));\n  });\n  return fsMap;\n};\n\n/**\n * Adds recursively files from the FS into the map based on the folder\n */\nexport const addAllFilesFromFolder = (map: Map<string, string>, workingDir: string): void => {\n  const walk = function (dir: string) {\n    let results: string[] = [];\n    const list = fs.readdirSync(dir);\n    list.forEach(function (file: string) {\n      file = path.join(dir, file);\n      const stat = fs.statSync(file);\n      if (stat && stat.isDirectory()) {\n        /* Recurse into a subdirectory */\n        results = results.concat(walk(file));\n      } else {\n        /* Is a file */\n        results.push(file);\n      }\n    });\n    return results;\n  };\n\n  const allFiles = walk(workingDir);\n\n  allFiles.forEach((lib) => {\n    const fsPath = '/node_modules/@types' + lib.replace(workingDir, '');\n    const content = fs.readFileSync(lib, 'utf8');\n    const validExtensions = ['.ts', '.tsx'];\n\n    if (validExtensions.includes(path.extname(fsPath))) {\n      map.set(fsPath, content);\n    }\n  });\n};\n\n/** Adds all files from `node_modules/@types` into the FS Map */\nexport const addFilesForTypesIntoFolder = (map: Map<string, string>) =>\n  addAllFilesFromFolder(map, 'node_modules/@types');\n\nfunction notImplemented(methodName: string): any {\n  throw new Error(`Method '${methodName}' is not implemented.`);\n}\n\n/** The default compiler options if TypeScript could ever change the compiler options */\nconst defaultCompilerOptions = (ts: typeof import('typescript')): CompilerOptions => {\n  return {\n    ...ts.getDefaultCompilerOptions(),\n    jsx: ts.JsxEmit.React,\n    strict: true,\n    esModuleInterop: true,\n    module: ts.ModuleKind.ESNext,\n    suppressOutputPathCheck: true,\n    skipLibCheck: true,\n    skipDefaultLibCheck: true,\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\n  };\n};\n\n// \"/DOM.d.ts\" => \"/lib.dom.d.ts\"\nconst libize = (path: string) => path.replace('/', '/lib.').toLowerCase();\n\n/**\n * Creates an in-memory System object which can be used in a TypeScript program, this\n * is what provides read/write aspects of the virtual fs\n */\nexport function createSystem(files: Map<string, string>): System {\n  return {\n    args: [],\n    createDirectory: () => notImplemented('createDirectory'),\n    // TODO: could make a real file tree\n    directoryExists: (directory) => {\n      return Array.from(files.keys()).some((path) => path.startsWith(directory));\n    },\n    exit: () => notImplemented('exit'),\n    fileExists: (fileName) => files.has(fileName) || files.has(libize(fileName)),\n    getCurrentDirectory: () => '/',\n    getDirectories: () => [],\n    getExecutingFilePath: () => notImplemented('getExecutingFilePath'),\n    readDirectory: (directory) => (directory === '/' ? Array.from(files.keys()) : []),\n    readFile: (fileName) => files.get(fileName) || files.get(libize(fileName)),\n    resolvePath: (path) => path,\n    newLine: '\\n',\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented('write'),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents);\n    },\n  };\n}\n\n/**\n * Creates a file-system backed System object which can be used in a TypeScript program, you provide\n * a set of virtual files which are prioritised over the FS versions, then a path to the root of your\n * project (basically the folder your node_modules lives)\n */\nexport function createFSBackedSystem(\n  files: Map<string, string>,\n  _projectRoot: string,\n  ts: TS,\n  tsLibDirectory?: string\n): System {\n  // We need to make an isolated folder for the tsconfig, but also need to be able to resolve the\n  // existing node_modules structures going back through the history\n  const root = _projectRoot + '/vfs';\n\n  // The default System in TypeScript\n  const nodeSys = ts.sys;\n  const tsLib = tsLibDirectory ?? path.dirname(require.resolve('typescript'));\n\n  return {\n    // @ts-ignore\n    name: 'fs-vfs',\n    root,\n    args: [],\n    realpath: (directory) => {\n      if (nodeSys.realpath) return nodeSys.realpath(directory);\n      return directory;\n    },\n    createDirectory: () => notImplemented('createDirectory'),\n    // TODO: could make a real file tree\n    directoryExists: (directory) => {\n      return (\n        Array.from(files.keys()).some((path) => path.startsWith(directory)) ||\n        nodeSys.directoryExists(directory)\n      );\n    },\n    exit: nodeSys.exit,\n    fileExists: (fileName) => {\n      if (files.has(fileName)) return true;\n      // Don't let other tsconfigs end up touching the vfs\n      if (fileName.includes('tsconfig.json') || fileName.includes('tsconfig.json')) return false;\n      if (fileName.startsWith('/lib')) {\n        const tsLibName = `${tsLib}/${fileName.replace('/', '')}`;\n        return nodeSys.fileExists(tsLibName);\n      }\n      return nodeSys.fileExists(fileName);\n    },\n    getCurrentDirectory: () => root,\n    getDirectories: nodeSys.getDirectories,\n    getExecutingFilePath: () => notImplemented('getExecutingFilePath'),\n    readDirectory: (...args) => {\n      if (args[0] === '/') {\n        return Array.from(files.keys());\n      } else {\n        return nodeSys.readDirectory(...args);\n      }\n    },\n    readFile: (fileName) => {\n      if (files.has(fileName)) return files.get(fileName);\n      if (fileName.startsWith('/lib')) {\n        const tsLibName = `${tsLib}/${fileName.replace('/', '')}`;\n        const result = nodeSys.readFile(tsLibName);\n        if (!result) {\n          const libs = nodeSys.readDirectory(tsLib);\n          throw new Error(\n            `TSVFS: A request was made for ${tsLibName} but there wasn't a file found in the file map. You likely have a mismatch in the compiler options for the CDN download vs the compiler program. Existing Libs: ${libs}.`\n          );\n        }\n        return result;\n      }\n      return nodeSys.readFile(fileName);\n    },\n    resolvePath: (path) => {\n      if (files.has(path)) return path;\n      return nodeSys.resolvePath(path);\n    },\n    newLine: '\\n',\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented('write'),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents);\n    },\n  };\n}\n\n/**\n * Creates an in-memory CompilerHost -which is essentially an extra wrapper to System\n * which works with TypeScript objects - returns both a compiler host, and a way to add new SourceFile\n * instances to the in-memory file system.\n */\nexport function createVirtualCompilerHost(sys: System, compilerOptions: CompilerOptions, ts: TS) {\n  const sourceFiles = new Map<string, SourceFile>();\n  const save = (sourceFile: SourceFile) => {\n    sourceFiles.set(sourceFile.fileName, sourceFile);\n    return sourceFile;\n  };\n\n  type Return = {\n    compilerHost: CompilerHost;\n    updateFile: (sourceFile: SourceFile) => boolean;\n  };\n\n  const vHost: Return = {\n    compilerHost: {\n      ...sys,\n      getCanonicalFileName: (fileName) => fileName,\n      getDefaultLibFileName: () => '/' + ts.getDefaultLibFileName(compilerOptions), // '/lib.d.ts',\n      // getDefaultLibLocation: () => '/',\n      getDirectories: () => [],\n      getNewLine: () => sys.newLine,\n      getSourceFile: (fileName) => {\n        return (\n          sourceFiles.get(fileName) ||\n          save(\n            ts.createSourceFile(\n              fileName,\n              sys.readFile(fileName)!,\n              compilerOptions.target || defaultCompilerOptions(ts).target!,\n              false\n            )\n          )\n        );\n      },\n      useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n    },\n    updateFile: (sourceFile) => {\n      const alreadyExists = sourceFiles.has(sourceFile.fileName);\n      sys.writeFile(sourceFile.fileName, sourceFile.text);\n      sourceFiles.set(sourceFile.fileName, sourceFile);\n      return alreadyExists;\n    },\n  };\n  return vHost;\n}\n\n/**\n * Creates an object which can host a language service against the virtual file-system\n */\nexport function createVirtualLanguageServiceHost(\n  sys: System,\n  rootFiles: string[],\n  compilerOptions: CompilerOptions,\n  ts: TS,\n  customTransformers?: CustomTransformers\n) {\n  const fileNames = [...rootFiles];\n  const { compilerHost, updateFile } = createVirtualCompilerHost(sys, compilerOptions, ts);\n  const fileVersions = new Map<string, string>();\n  let projectVersion = 0;\n  const languageServiceHost: LanguageServiceHost = {\n    ...compilerHost,\n    getProjectVersion: () => projectVersion.toString(),\n    getCompilationSettings: () => compilerOptions,\n    getCustomTransformers: () => customTransformers,\n    // A couple weeks of 4.8 TypeScript nightlies had a bug where the Program's\n    // list of files was just a reference to the array returned by this host method,\n    // which means mutations by the host that ought to result in a new Program being\n    // created were not detected, since the old list of files and the new list of files\n    // were in fact a reference to the same underlying array. That was fixed in\n    // https://github.com/microsoft/TypeScript/pull/49813, but since the twoslash runner\n    // is used in bisecting for changes, it needs to guard against being busted in that\n    // couple-week period, so we defensively make a slice here.\n    getScriptFileNames: () => fileNames.slice(),\n    getScriptSnapshot: (fileName) => {\n      const contents = sys.readFile(fileName);\n      if (contents) {\n        return ts.ScriptSnapshot.fromString(contents);\n      }\n      return;\n    },\n    getScriptVersion: (fileName) => {\n      return fileVersions.get(fileName) || '0';\n    },\n    writeFile: sys.writeFile,\n  };\n\n  type Return = {\n    languageServiceHost: LanguageServiceHost;\n    updateFile: (sourceFile: import('typescript').SourceFile) => void;\n  };\n\n  const lsHost: Return = {\n    languageServiceHost,\n    updateFile: (sourceFile) => {\n      projectVersion++;\n      fileVersions.set(sourceFile.fileName, projectVersion.toString());\n      if (!fileNames.includes(sourceFile.fileName)) {\n        fileNames.push(sourceFile.fileName);\n      }\n      updateFile(sourceFile);\n    },\n  };\n  return lsHost;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = void 0;\nfunction binarySearch(offsets, start) {\n    let low = 0;\n    let high = offsets.length - 1;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = offsets[mid];\n        if (midValue < start) {\n            low = mid + 1;\n        }\n        else if (midValue > start) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            break;\n        }\n    }\n    return Math.max(Math.min(low, high, offsets.length - 1), 0);\n}\nexports.binarySearch = binarySearch;\n//# sourceMappingURL=binarySearch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStack = exports.track = exports.resetOffsetStack = exports.offsetStack = exports.setTracking = void 0;\nlet tracking = true;\nlet stackOffset = 0;\nfunction setTracking(value) {\n    tracking = value;\n}\nexports.setTracking = setTracking;\nfunction offsetStack() {\n    stackOffset++;\n}\nexports.offsetStack = offsetStack;\nfunction resetOffsetStack() {\n    stackOffset--;\n}\nexports.resetOffsetStack = resetOffsetStack;\nfunction track(segments, stacks = []) {\n    return [\n        new Proxy(segments, {\n            get(target, prop, receiver) {\n                if (tracking) {\n                    if (prop === 'push')\n                        return push;\n                    if (prop === 'pop')\n                        return pop;\n                    if (prop === 'shift')\n                        return shift;\n                    if (prop === 'unshift')\n                        return unshift;\n                    if (prop === 'splice')\n                        return splice;\n                    if (prop === 'sort')\n                        return sort;\n                    if (prop === 'reverse')\n                        return reverse;\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        }),\n        stacks,\n    ];\n    function push(...items) {\n        stacks.push({ stack: getStack(), length: items.length });\n        return segments.push(...items);\n    }\n    function pop() {\n        if (stacks.length) {\n            const last = stacks[stacks.length - 1];\n            if (last.length > 1) {\n                last.length--;\n            }\n            else {\n                stacks.pop();\n            }\n        }\n        return segments.pop();\n    }\n    function shift() {\n        if (stacks.length) {\n            const first = stacks[0];\n            if (first.length > 1) {\n                first.length--;\n            }\n            else {\n                stacks.shift();\n            }\n        }\n        return segments.shift();\n    }\n    function unshift(...items) {\n        stacks.unshift({ stack: getStack(), length: items.length });\n        return segments.unshift(...items);\n    }\n    function splice(start, deleteCount, ...items) {\n        if (deleteCount === undefined) {\n            deleteCount = segments.length - start;\n        }\n        let _stackStart = 0;\n        let operateIndex;\n        for (let i = 0; i < stacks.length; i++) {\n            const stack = stacks[i];\n            const stackStart = _stackStart;\n            const stackEnd = stackStart + stack.length;\n            _stackStart = stackEnd;\n            if (start >= stackStart) {\n                operateIndex = i + 1;\n                const originalLength = stack.length;\n                stack.length = start - stackStart;\n                stacks.splice(operateIndex, 0, { stack: stack.stack, length: originalLength - stack.length });\n                break;\n            }\n        }\n        if (operateIndex === undefined) {\n            throw new Error('Invalid splice operation');\n        }\n        let _deleteCount = deleteCount;\n        for (let i = operateIndex; i < stacks.length; i++) {\n            const stack = stacks[i];\n            while (_deleteCount > 0 && stack.length > 0) {\n                stack.length--;\n                _deleteCount--;\n            }\n            if (_deleteCount === 0) {\n                break;\n            }\n        }\n        stacks.splice(operateIndex, 0, { stack: getStack(), length: items.length });\n        return segments.splice(start, deleteCount, ...items);\n    }\n    function sort(compareFn) {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.sort(compareFn);\n    }\n    function reverse() {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.reverse();\n    }\n}\nexports.track = track;\nfunction getStack() {\n    const stack = new Error().stack;\n    let source = stack.split('\\n')[3 + stackOffset].trim();\n    if (source.endsWith(')')) {\n        source = source.slice(source.lastIndexOf('(') + 1, -1);\n    }\n    else {\n        source = source.slice(source.lastIndexOf(' ') + 1);\n    }\n    return source;\n}\nexports.getStack = getStack;\n//# sourceMappingURL=track.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceRange = exports.replaceSourceRange = exports.replaceAll = exports.replace = exports.create = exports.toString = exports.getLength = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst track_1 = require(\"./track\");\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./track\"), exports);\nfunction getLength(segments) {\n    let length = 0;\n    for (const segment of segments) {\n        length += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return length;\n}\nexports.getLength = getLength;\nfunction toString(segments) {\n    return segments.map(s => typeof s === 'string' ? s : s[0]).join('');\n}\nexports.toString = toString;\nfunction create(source) {\n    return [[source, undefined, 0]];\n}\nexports.create = create;\nfunction replace(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const match = str.match(pattern);\n    if (match && match.index !== undefined) {\n        const startOffset = match.index;\n        const endOffset = startOffset + match[0].length;\n        (0, track_1.offsetStack)();\n        replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n        (0, track_1.resetOffsetStack)();\n    }\n}\nexports.replace = replace;\nfunction replaceAll(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const allMatch = str.matchAll(pattern);\n    let length = str.length;\n    let lengthDiff = 0;\n    for (const match of allMatch) {\n        if (match.index !== undefined) {\n            const startOffset = match.index + lengthDiff;\n            const endOffset = startOffset + match[0].length;\n            (0, track_1.offsetStack)();\n            replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n            (0, track_1.resetOffsetStack)();\n            const newLength = getLength(segments);\n            lengthDiff += newLength - length;\n            length = newLength;\n        }\n    }\n}\nexports.replaceAll = replaceAll;\nfunction replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {\n    for (const segment of segments) {\n        if (typeof segment === 'string') {\n            continue;\n        }\n        if (segment[1] === source) {\n            const segmentStart = segment[2];\n            const segmentEnd = segment[2] + segment[0].length;\n            if (segmentStart <= startOffset && segmentEnd >= endOffset) {\n                const inserts = [];\n                if (startOffset > segmentStart) {\n                    inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));\n                }\n                for (const newSegment of newSegments) {\n                    inserts.push(newSegment);\n                }\n                if (endOffset < segmentEnd) {\n                    inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));\n                }\n                combineStrings(inserts);\n                (0, track_1.offsetStack)();\n                segments.splice(segments.indexOf(segment), 1, ...inserts);\n                (0, track_1.resetOffsetStack)();\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.replaceSourceRange = replaceSourceRange;\nfunction replaceRange(segments, startOffset, endOffset, ...newSegments) {\n    const offsets = toOffsets(segments);\n    const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);\n    const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);\n    const startSegment = segments[startIndex];\n    const endSegment = segments[endIndex];\n    const startSegmentStart = offsets[startIndex];\n    const endSegmentStart = offsets[endIndex];\n    const endSegmentEnd = offsets[endIndex] + (typeof endSegment === 'string' ? endSegment.length : endSegment[0].length);\n    const inserts = [];\n    if (startOffset > startSegmentStart) {\n        inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));\n    }\n    for (const newSegment of newSegments) {\n        inserts.push(newSegment);\n    }\n    if (endOffset < endSegmentEnd) {\n        inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));\n    }\n    combineStrings(inserts);\n    (0, track_1.offsetStack)();\n    segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);\n    (0, track_1.resetOffsetStack)();\n}\nexports.replaceRange = replaceRange;\nfunction combineStrings(segments) {\n    for (let i = segments.length - 1; i >= 1; i--) {\n        if (typeof segments[i] === 'string' && typeof segments[i - 1] === 'string') {\n            segments[i - 1] = segments[i - 1] + segments[i];\n            (0, track_1.offsetStack)();\n            segments.splice(i, 1);\n            (0, track_1.resetOffsetStack)();\n        }\n    }\n}\nfunction trimSegmentEnd(segment, trimEnd) {\n    if (typeof segment === 'string') {\n        return segment.slice(0, trimEnd);\n    }\n    return [\n        segment[0].slice(0, trimEnd),\n        ...segment.slice(1),\n    ];\n}\nfunction trimSegmentStart(segment, trimStart) {\n    if (typeof segment === 'string') {\n        return segment.slice(trimStart);\n    }\n    if (trimStart < 0) {\n        trimStart += segment[0].length;\n    }\n    return [\n        segment[0].slice(trimStart),\n        segment[1],\n        segment[2] + trimStart,\n        ...segment.slice(3),\n    ];\n}\nfunction toOffsets(segments) {\n    const offsets = [];\n    let offset = 0;\n    for (const segment of segments) {\n        offsets.push(offset);\n        offset += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return offsets;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = void 0;\nfunction binarySearch(values, searchValue) {\n    let low = 0;\n    let high = values.length - 1;\n    let match;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = values[mid];\n        if (midValue < searchValue) {\n            low = mid + 1;\n        }\n        else if (midValue > searchValue) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            match = mid;\n            break;\n        }\n    }\n    const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);\n    const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);\n    return { low: finalLow, high: finalHigh, match };\n}\nexports.binarySearch = binarySearch;\n//# sourceMappingURL=binarySearch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translateOffset = void 0;\nfunction translateOffset(start, fromOffsets, toOffsets, lengths) {\n    for (let i = 0; i < fromOffsets.length; i++) {\n        const fromOffset = fromOffsets[i];\n        const toOffset = toOffsets[i];\n        const length = lengths[i];\n        if (start >= fromOffset && start <= fromOffset + length) {\n            return toOffset + start - fromOffset;\n        }\n    }\n}\nexports.translateOffset = translateOffset;\n//# sourceMappingURL=translateOffset.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceMap = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst translateOffset_1 = require(\"./translateOffset\");\nclass SourceMap {\n    constructor(mappings) {\n        this.mappings = mappings;\n    }\n    getSourceOffset(generatedOffset) {\n        for (const mapped of this.findMatching(generatedOffset, 'generatedOffsets', 'sourceOffsets')) {\n            return mapped;\n        }\n    }\n    getGeneratedOffset(sourceOffset) {\n        for (const mapped of this.findMatching(sourceOffset, 'sourceOffsets', 'generatedOffsets')) {\n            return mapped;\n        }\n    }\n    getSourceOffsets(generatedOffset) {\n        return this.findMatching(generatedOffset, 'generatedOffsets', 'sourceOffsets');\n    }\n    getGeneratedOffsets(sourceOffset) {\n        return this.findMatching(sourceOffset, 'sourceOffsets', 'generatedOffsets');\n    }\n    *findMatching(offset, fromRange, toRange) {\n        const memo = this.getMemoBasedOnRange(fromRange);\n        if (memo.offsets.length === 0) {\n            return;\n        }\n        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);\n        const skip = new Set();\n        for (let i = start; i <= end; i++) {\n            for (const mapping of memo.mappings[i]) {\n                if (skip.has(mapping)) {\n                    continue;\n                }\n                skip.add(mapping);\n                const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], mapping.lengths);\n                if (mapped !== undefined) {\n                    yield [mapped, mapping];\n                }\n            }\n        }\n    }\n    getMemoBasedOnRange(fromRange) {\n        return fromRange === 'sourceOffsets'\n            ? this.sourceCodeOffsetsMemo ??= this.createMemo('sourceOffsets')\n            : this.generatedCodeOffsetsMemo ??= this.createMemo('generatedOffsets');\n    }\n    createMemo(key) {\n        const offsetsSet = new Set();\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                offsetsSet.add(mapping[key][i]);\n                offsetsSet.add(mapping[key][i] + mapping.lengths[i]);\n            }\n        }\n        const offsets = [...offsetsSet].sort((a, b) => a - b);\n        const mappings = offsets.map(() => new Set());\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;\n                const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + mapping.lengths[i]).match;\n                for (let i = startIndex; i <= endIndex; i++) {\n                    mappings[i].add(mapping);\n                }\n            }\n        }\n        return { offsets, mappings };\n    }\n}\nexports.SourceMap = SourceMap;\n//# sourceMappingURL=sourceMap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildMappings = void 0;\nfunction buildMappings(chunks) {\n    let length = 0;\n    const mappings = [];\n    for (const segment of chunks) {\n        if (typeof segment === 'string') {\n            length += segment.length;\n        }\n        else {\n            mappings.push({\n                source: segment[1],\n                sourceOffsets: [segment[2]],\n                generatedOffsets: [length],\n                lengths: [segment[0].length],\n                data: segment[3],\n            });\n            length += segment[0].length;\n        }\n    }\n    return mappings;\n}\nexports.buildMappings = buildMappings;\n//# sourceMappingURL=buildMappings.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildStacks = void 0;\nfunction buildStacks(chunks, stacks) {\n    let offset = 0;\n    let index = 0;\n    const result = [];\n    for (const stack of stacks) {\n        const start = offset;\n        for (let i = 0; i < stack.length; i++) {\n            const segment = chunks[index + i];\n            if (typeof segment === 'string') {\n                offset += segment.length;\n            }\n            else {\n                offset += segment[0].length;\n            }\n        }\n        index += stack.length;\n        result.push({\n            source: stack.stack,\n            range: [start, offset],\n        });\n    }\n    return result;\n}\nexports.buildStacks = buildStacks;\n//# sourceMappingURL=buildStacks.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"muggle-string\"), exports);\n__exportStar(require(\"./lib/sourceMap\"), exports);\n__exportStar(require(\"./lib/translateOffset\"), exports);\n__exportStar(require(\"./lib/buildMappings\"), exports);\n__exportStar(require(\"./lib/buildStacks\"), exports);\n//# sourceMappingURL=index.js.map","import type ts from 'typescript';\nimport { SourceMap } from '@volar/source-map';\nimport type { Mapping } from '@volar/source-map';\n\nexport type VirtualMap = Map<string, SourceMappedFile>;\nexport type { Mapping };\n\nexport interface FileSpan extends ts.TextSpan {\n  fileName: string;\n}\n\nexport class SourceMappedFile extends SourceMap {\n  readonly sourceFile: ts.SourceFile;\n  readonly sourceFileId: string;\n  readonly generatedFileId: string;\n\n  constructor(\n    mappings: readonly Mapping[],\n    params: {\n      sourceFile: ts.SourceFile;\n      sourceFileId: string;\n      generatedFileId: string;\n    }\n  ) {\n    super(mappings as Mapping[]);\n    this.sourceFile = params.sourceFile;\n    this.sourceFileId = params.sourceFileId;\n    this.generatedFileId = params.generatedFileId;\n  }\n\n  getSourceSpan(span: ts.TextSpan | number): FileSpan {\n    const sourceStart = this.getSourceOffset(typeof span === 'number' ? span : span.start);\n    if (sourceStart != null) {\n      const sourceEnd =\n        typeof span !== 'number' ? this.getSourceOffset(span.start + span.length - 1) : null;\n      return {\n        fileName: this.sourceFileId,\n        start: sourceStart[0],\n        length:\n          sourceEnd != null\n            ? sourceEnd[0] - sourceStart[0] + 1\n            : typeof span !== 'number'\n              ? span.length\n              : 1,\n      };\n    } else {\n      return {\n        fileName: this.generatedFileId,\n        start: typeof span !== 'number' ? span.start : span,\n        length: typeof span !== 'number' ? span.length : 1,\n      };\n    }\n  }\n}\n","import ts from 'typescript';\nimport * as path from 'node:path';\nimport type { GraphQLSPConfig } from '@gql.tada/internal';\nimport { createVirtualLanguageServiceHost } from './vendor/typescript-vfs';\n\nimport type { VirtualMap, SourceMappedFile, FileSpan } from './mapping';\n\nimport type { SourcePosition } from './utils';\nimport { spanToFilePosition } from './utils';\n\nfunction maybeBind<T extends Function>(that: object, fn: T | undefined): T {\n  return fn ? fn.bind(that) : fn;\n}\n\nexport interface PluginCreateInfo<Config extends {} = GraphQLSPConfig>\n  extends ts.server.PluginCreateInfo {\n  config: Config;\n}\n\nexport interface ProgramContainer {\n  readonly program: ts.Program;\n  readonly languageService: ts.LanguageService;\n  buildPluginInfo<Config extends {}>(config: Config): PluginCreateInfo<Config>;\n\n  getSourceFile(fileId: string): ts.SourceFile | undefined;\n  getSourceFiles(): readonly ts.SourceFile[];\n  getSourceMappedFile(fileId: string | ts.SourceFile): SourceMappedFile | undefined;\n  getSourceSpan(fileId: string | ts.SourceFile, span: ts.TextSpan | number): FileSpan;\n  getSourcePosition(fileId: string | ts.SourceFile, span: ts.TextSpan | number): SourcePosition;\n}\n\nexport interface ContainerParams {\n  virtualMap: VirtualMap;\n  projectRoot: string;\n  compilerHost: ts.CompilerHost;\n  rootNames: readonly string[];\n  options: ts.CompilerOptions;\n  system: ts.System;\n}\n\nexport const buildContainer = (params: ContainerParams): ProgramContainer => {\n  let program: ts.Program | undefined;\n  let service: ts.LanguageService | undefined;\n  let serviceHost: ts.LanguageServiceHost | undefined;\n  let pluginInfo: PluginCreateInfo<any> | undefined;\n\n  const getLanguageServiceHost = () =>\n    serviceHost ||\n    (serviceHost = createVirtualLanguageServiceHost(\n      params.system,\n      [...params.rootNames],\n      params.options,\n      ts\n    ).languageServiceHost);\n\n  const getLanguageService = () =>\n    service ||\n    (service = buildLanguageService({\n      system: params.system,\n      rootNames: params.rootNames,\n      virtualMap: params.virtualMap,\n      options: params.options,\n      projectRoot: params.projectRoot,\n      languageServiceHost: getLanguageServiceHost(),\n    }));\n\n  const getProgram = () => {\n    if (!program) {\n      program =\n        getLanguageService().getProgram() ||\n        ts.createProgram({\n          rootNames: params.rootNames,\n          options: params.options,\n          host: params.compilerHost,\n        });\n    }\n    return program;\n  };\n\n  return {\n    get program() {\n      return getProgram();\n    },\n    get languageService() {\n      return getLanguageService();\n    },\n    buildPluginInfo(config) {\n      return (\n        pluginInfo ||\n        (pluginInfo = buildPluginInfo({\n          getLanguageService,\n          getLanguageServiceHost,\n          projectRoot: params.projectRoot,\n          rootNames: params.rootNames,\n          system: params.system,\n          options: params.options,\n          config,\n        }))\n      );\n    },\n\n    getSourceFile(fileId) {\n      return getProgram().getSourceFile(fileId);\n    },\n    getSourceFiles() {\n      return getProgram().getSourceFiles();\n    },\n    getSourceMappedFile(file) {\n      const fileId = typeof file !== 'string' ? file.fileName : file;\n      return params.virtualMap.get(fileId);\n    },\n    getSourceSpan(file, span) {\n      const fileId = typeof file !== 'string' ? file.fileName : file;\n      const mappedFile = params.virtualMap.get(fileId);\n      return mappedFile\n        ? mappedFile.getSourceSpan(span)\n        : {\n            fileName: fileId,\n            start: typeof span !== 'number' ? span.start : span,\n            length: typeof span !== 'number' ? span.length : 1,\n          };\n    },\n    getSourcePosition(file, position) {\n      const fileId = typeof file !== 'string' ? file.fileName : file;\n      const mappedFile = params.virtualMap.get(fileId);\n      if (mappedFile) {\n        const span = mappedFile.getSourceSpan(position);\n        if (span.fileName === mappedFile.sourceFileId)\n          return spanToFilePosition(mappedFile.sourceFile, span);\n      }\n      return spanToFilePosition(\n        typeof file === 'string' ? getProgram().getSourceFile(file)! : file,\n        position\n      );\n    },\n  };\n};\n\nconst buildProgram = (params: {\n  program: ts.Program;\n  virtualMap: VirtualMap;\n  projectRoot: string;\n}): ts.Program => {\n  const { program, virtualMap, projectRoot } = params;\n\n  const isSourceFileFromExternalLibrary = maybeBind(\n    program,\n    program.isSourceFileFromExternalLibrary\n  );\n  const getModeForResolutionAtIndex = maybeBind(program, program.getModeForResolutionAtIndex);\n  const getSourceFile = maybeBind(program, program.getSourceFile);\n  const getSourceFiles = maybeBind(program, program.getSourceFiles);\n\n  /** Remap source file to generated source file if it's a mapped file */\n  const mapSourceFileFn =\n    <TReturn, TArgs extends readonly any[]>(\n      fileFn: (file: ts.SourceFile, ...args: TArgs) => TReturn\n    ) =>\n    (file: ts.SourceFile | undefined, ...args: TArgs): TReturn => {\n      const mappedFile = file && virtualMap.get(file.fileName);\n      if (mappedFile && mappedFile.sourceFileId === file?.fileName)\n        file = getSourceFile(mappedFile.generatedFileId) || file;\n      return fileFn.call(program, file!, ...args);\n    };\n\n  return Object.assign(program, {\n    getSyntacticDiagnostics: mapSourceFileFn(program.getSyntacticDiagnostics),\n    getSemanticDiagnostics: mapSourceFileFn(program.getSemanticDiagnostics),\n    getDeclarationDiagnostics: mapSourceFileFn(program.getDeclarationDiagnostics),\n    isSourceFileDefaultLibrary: mapSourceFileFn(program.isSourceFileDefaultLibrary),\n    getModeForUsageLocation: mapSourceFileFn(program.getModeForUsageLocation),\n\n    isSourceFileFromExternalLibrary(source) {\n      const mappedFile = virtualMap.get(source.fileName);\n      return (\n        !!(mappedFile && mappedFile.sourceFileId === source.fileName) ||\n        isSourceFileFromExternalLibrary(source)\n      );\n    },\n\n    getSourceFiles() {\n      const sourceFiles: ts.SourceFile[] = [];\n      for (const sourceFile of getSourceFiles()) {\n        const relativePath = path.relative(projectRoot, sourceFile.fileName);\n        if (\n          !relativePath.startsWith('..') &&\n          !program.isSourceFileFromExternalLibrary(sourceFile)\n        ) {\n          sourceFiles.push(sourceFile);\n        }\n      }\n      return sourceFiles;\n    },\n\n    getSourceFile(fileId) {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) fileId = mappedFile.generatedFileId;\n      return getSourceFile(fileId);\n    },\n\n    getModeForResolutionAtIndex(file, index) {\n      const mappedFile = virtualMap.get(file.fileName);\n      if (mappedFile && mappedFile.sourceFileId === file.fileName) {\n        file = getSourceFile(mappedFile.generatedFileId) || file;\n        index = mappedFile.getGeneratedOffset(index)?.[0] ?? index;\n      }\n      return getModeForResolutionAtIndex(file, index);\n    },\n  } satisfies Partial<ts.Program>);\n};\n\nconst buildLanguageService = (params: {\n  virtualMap: VirtualMap;\n  languageServiceHost: ts.LanguageServiceHost;\n  system: ts.System;\n  rootNames: readonly string[];\n  projectRoot: string;\n  options: ts.CompilerOptions;\n}): ts.LanguageService => {\n  const { virtualMap } = params;\n  const languageService = ts.createLanguageService(params.languageServiceHost);\n  const getProgram = maybeBind(languageService, languageService.getProgram);\n\n  /** Remap filename to generated file if it's a mapped file */\n  const mapFileFn =\n    <TReturn, TArgs extends readonly any[]>(fileFn: (fileId: string, ...args: TArgs) => TReturn) =>\n    (fileId: string, ...args: TArgs): TReturn => {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) fileId = mappedFile.generatedFileId;\n      return fileFn.call(languageService, fileId, ...args);\n    };\n\n  /** Remap input to generated file and span if it's a mapped file */\n  const mapFileTextSpanFn =\n    <TReturn, TArgs extends readonly any[]>(\n      textSpanFn: (fileId: string, span: ts.TextSpan, ...args: TArgs) => TReturn\n    ) =>\n    (fileId: string, span: ts.TextSpan, ...args: TArgs): TReturn => {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) {\n        fileId = mappedFile.generatedFileId;\n        const start = mappedFile.getGeneratedOffset(span.start)?.[0];\n        const end = mappedFile.getGeneratedOffset(span.start + span.length - 1)?.[0];\n        if (start != null) {\n          span = { start, length: span.length };\n          if (end != null) span.length = end - start + 1;\n        }\n      }\n      return textSpanFn.call(languageService, fileId, span, ...args);\n    };\n\n  /** Remap input to generated file and range if it's a mapped file */\n  const mapFileTextRangeFn =\n    <TReturn, TArgs extends readonly any[]>(\n      textSpanFn: (fileId: string, range: ts.TextRange, ...args: TArgs) => TReturn\n    ) =>\n    (fileId: string, range: ts.TextRange, ...args: TArgs): TReturn => {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) {\n        fileId = mappedFile.generatedFileId;\n        const pos = mappedFile.getGeneratedOffset(range.pos)?.[0];\n        const end = mappedFile.getGeneratedOffset(range.end)?.[0];\n        if (pos != null) {\n          range = { pos, end: pos + (range.end - range.pos) };\n          if (end != null) range.end = end;\n        }\n      }\n      return textSpanFn.call(languageService, fileId, range, ...args);\n    };\n\n  /** Remap input to generated file and position if it's a mapped file */\n  const mapFilePositionFn =\n    <TReturn, TArgs extends readonly any[]>(\n      positionFn: (fileId: string, position: number, ...args: TArgs) => TReturn\n    ) =>\n    (fileId: string, position: number, ...args: TArgs): TReturn => {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) {\n        fileId = mappedFile.generatedFileId;\n        position = mappedFile.getGeneratedOffset(position)?.[0] ?? position;\n      }\n      return positionFn.call(languageService, fileId, position, ...args);\n    };\n\n  /** Remap input to generated file and position if it's a mapped file */\n  const mapFileStartEndFn =\n    <TReturn, TArgs extends readonly any[]>(\n      positionFn: (fileId: string, start: number, end: number, ...args: TArgs) => TReturn\n    ) =>\n    (fileId: string, start: number, end: number, ...args: TArgs): TReturn => {\n      const mappedFile = virtualMap.get(fileId);\n      if (mappedFile && mappedFile.sourceFileId === fileId) {\n        fileId = mappedFile.generatedFileId;\n        start = mappedFile.getGeneratedOffset(start)?.[0] ?? start;\n        end = mappedFile.getGeneratedOffset(end)?.[0] ?? end;\n      }\n      return positionFn.call(languageService, fileId, start, end, ...args);\n    };\n\n  let program: ts.Program | undefined;\n\n  return Object.assign(languageService, {\n    getProgram() {\n      if (program) {\n        return program;\n      } else {\n        const serviceProgram = getProgram();\n        return serviceProgram\n          ? (program = buildProgram({\n              program: serviceProgram,\n              virtualMap: params.virtualMap,\n              projectRoot: params.projectRoot,\n            }))\n          : undefined;\n      }\n    },\n\n    getReferencesAtPosition: mapFilePositionFn(languageService.getReferencesAtPosition),\n    findReferences: mapFilePositionFn(languageService.findReferences),\n    getDefinitionAtPosition: mapFilePositionFn(languageService.getDefinitionAtPosition),\n    getDefinitionAndBoundSpan: mapFilePositionFn(languageService.getDefinitionAndBoundSpan),\n    getTypeDefinitionAtPosition: mapFilePositionFn(languageService.getTypeDefinitionAtPosition),\n    getImplementationAtPosition: mapFilePositionFn(languageService.getImplementationAtPosition),\n    getCompletionsAtPosition: mapFilePositionFn(languageService.getCompletionsAtPosition),\n    getCompletionEntryDetails: mapFilePositionFn(languageService.getCompletionEntryDetails),\n    getCompletionEntrySymbol: mapFilePositionFn(languageService.getCompletionEntrySymbol),\n    getQuickInfoAtPosition: mapFilePositionFn(languageService.getQuickInfoAtPosition),\n    getBreakpointStatementAtPosition: mapFilePositionFn(\n      languageService.getBreakpointStatementAtPosition\n    ),\n    getSignatureHelpItems: mapFilePositionFn(languageService.getSignatureHelpItems),\n    getRenameInfo: mapFilePositionFn(languageService.getRenameInfo),\n    getSmartSelectionRange: mapFilePositionFn(languageService.getSmartSelectionRange),\n    getDocumentHighlights: mapFilePositionFn(languageService.getDocumentHighlights),\n    prepareCallHierarchy: mapFilePositionFn(languageService.prepareCallHierarchy),\n    provideCallHierarchyIncomingCalls: mapFilePositionFn(\n      languageService.provideCallHierarchyIncomingCalls\n    ),\n    provideCallHierarchyOutgoingCalls: mapFilePositionFn(\n      languageService.provideCallHierarchyOutgoingCalls\n    ),\n    getBraceMatchingAtPosition: mapFilePositionFn(languageService.getBraceMatchingAtPosition),\n    getIndentationAtPosition: mapFilePositionFn(languageService.getIndentationAtPosition),\n    getFormattingEditsAfterKeystroke: mapFilePositionFn(\n      languageService.getFormattingEditsAfterKeystroke\n    ),\n    getDocCommentTemplateAtPosition: mapFilePositionFn(\n      languageService.getDocCommentTemplateAtPosition\n    ),\n    isValidBraceCompletionAtPosition: mapFilePositionFn(\n      languageService.isValidBraceCompletionAtPosition\n    ),\n    getJsxClosingTagAtPosition: mapFilePositionFn(languageService.getJsxClosingTagAtPosition),\n    getLinkedEditingRangeAtPosition: mapFilePositionFn(\n      languageService.getLinkedEditingRangeAtPosition\n    ),\n    getSpanOfEnclosingComment: mapFilePositionFn(languageService.getSpanOfEnclosingComment),\n\n    getSyntacticClassifications: mapFileTextSpanFn(\n      languageService.getSyntacticClassifications\n    ) as typeof languageService.getSyntacticClassifications,\n    getSemanticClassifications: mapFileTextSpanFn(\n      languageService.getSemanticClassifications\n    ) as typeof languageService.getSemanticClassifications,\n    getEncodedSyntacticClassifications: mapFileTextSpanFn(\n      languageService.getEncodedSyntacticClassifications\n    ),\n    getEncodedSemanticClassifications: mapFileTextSpanFn(\n      languageService.getEncodedSemanticClassifications\n    ),\n    provideInlayHints: mapFileTextSpanFn(languageService.provideInlayHints),\n\n    getNameOrDottedNameSpan: mapFileStartEndFn(languageService.getNameOrDottedNameSpan),\n    getFormattingEditsForRange: mapFileStartEndFn(languageService.getFormattingEditsForRange),\n    getCodeFixesAtPosition: mapFileStartEndFn(languageService.getCodeFixesAtPosition),\n\n    getFileReferences: mapFileFn(languageService.getFileReferences),\n    getNavigationBarItems: mapFileFn(languageService.getNavigationBarItems),\n    getNavigationTree: mapFileFn(languageService.getNavigationTree),\n    getOutliningSpans: mapFileFn(languageService.getOutliningSpans),\n    getTodoComments: mapFileFn(languageService.getTodoComments),\n    getFormattingEditsForDocument: mapFileFn(languageService.getFormattingEditsForDocument),\n    getEditsForRefactor: mapFileFn(languageService.getEditsForRefactor),\n    getEmitOutput: mapFileFn(languageService.getEmitOutput),\n    getSuggestionDiagnostics: mapFileFn(languageService.getSuggestionDiagnostics),\n    getSemanticDiagnostics: mapFileFn(languageService.getSemanticDiagnostics),\n    getSyntacticDiagnostics: mapFileFn(languageService.getSyntacticDiagnostics),\n    getSupportedCodeFixes: mapFileFn(languageService.getSupportedCodeFixes),\n\n    toggleLineComment: mapFileTextRangeFn(languageService.toggleLineComment),\n    toggleMultilineComment: mapFileTextRangeFn(languageService.toggleMultilineComment),\n    commentSelection: mapFileTextRangeFn(languageService.commentSelection),\n    uncommentSelection: mapFileTextRangeFn(languageService.uncommentSelection),\n  } satisfies Partial<ts.LanguageService>);\n};\n\nconst buildPluginInfo = <Config extends {}>(params: {\n  config: Config;\n  projectRoot: string;\n  getLanguageService(): ts.LanguageService;\n  getLanguageServiceHost(): ts.LanguageServiceHost;\n  system: ts.System;\n  rootNames: readonly string[];\n  options: ts.CompilerOptions;\n}): PluginCreateInfo<Config> => {\n  let languageServiceHost: ts.LanguageServiceHost | undefined;\n  return {\n    config: params.config,\n\n    get languageService() {\n      return params.getLanguageService();\n    },\n\n    get languageServiceHost() {\n      return (\n        languageServiceHost ||\n        (languageServiceHost = createVirtualLanguageServiceHost(\n          params.system,\n          [...params.rootNames],\n          params.options,\n          ts\n        ).languageServiceHost)\n      );\n    },\n\n    // NOTE: this is an inexact and incomplete implementation\n    project: {\n      getProjectName: () => params.projectRoot,\n      projectService: { logger: console } as any,\n    } as PluginCreateInfo['project'],\n\n    // NOTE: this is an inexact and incomplete implementation\n    serverHost: {\n      ...params.system,\n      setImmediate,\n      clearImmediate,\n    } as PluginCreateInfo['serverHost'],\n  };\n};\n","import type ts from 'typescript';\nimport * as path from 'node:path';\nimport type { VirtualCode } from '@vue/language-core';\n\nlet _transformSvelte: typeof import('./svelte').transform;\nlet _transformVue: typeof import('./vue').transform;\n\nconst transformSvelte = async (\n  ...args: Parameters<typeof _transformSvelte>\n): Promise<ReturnType<typeof _transformSvelte>> => {\n  if (!_transformSvelte) _transformSvelte = (await import('./svelte')).transform;\n  return _transformSvelte(...args);\n};\n\nconst transformVue = async (\n  ...args: Parameters<typeof _transformVue>\n): Promise<ReturnType<typeof _transformVue>> => {\n  if (!_transformVue) _transformVue = (await import('./vue')).transform;\n  return _transformVue(...args);\n};\n\nexport const transformExtensions = ['.svelte', '.vue'] as const;\n\nexport const transform = (sourceFile: ts.SourceFile): Promise<VirtualCode | undefined> => {\n  const extname = path.extname(sourceFile.fileName);\n  if (extname === '.svelte') {\n    return transformSvelte(sourceFile);\n  } else if (extname === '.vue') {\n    return transformVue(sourceFile);\n  } else {\n    throw new Error(\n      `Tried transforming unknown file type \"${extname}\". Supported: ${transformExtensions.join(\n        ', '\n      )}`\n    );\n  }\n};\n","import ts from 'typescript';\nimport * as path from 'node:path';\nimport { createRequire } from 'node:module';\nimport { init } from '@0no-co/graphqlsp/api';\n\nimport { createFSBackedSystem, createVirtualCompilerHost } from './vendor/typescript-vfs';\n\nimport type { VirtualMap, Mapping } from './mapping';\nimport type { ProgramContainer } from './container';\nimport { SourceMappedFile } from './mapping';\nimport { buildContainer } from './container';\nimport { transform, transformExtensions } from './transformers';\n\nexport type VirtualExtension = (typeof transformExtensions)[number];\n\nexport interface ProgramFactoryParams {\n  rootPath: string;\n  configPath: string;\n}\n\nexport interface SourceFileParams {\n  fileId: string;\n  sourceText: string | ts.IScriptSnapshot;\n  scriptKind?: ts.ScriptKind;\n}\n\nexport interface MappedFileParams {\n  fileId: string;\n  mappings: readonly Mapping[];\n}\n\nexport interface ProgramFactory {\n  readonly projectPath: string;\n  readonly projectDirectories: readonly string[];\n\n  createSourceFile(params: SourceFileParams, scriptKind?: ts.ScriptKind): ts.SourceFile;\n  createExternalFiles(exts?: readonly VirtualExtension[]): readonly ts.SourceFile[];\n\n  addSourceFile(file: SourceFileParams | ts.SourceFile, addRootName?: boolean): this;\n  addMappedFile(file: SourceFileParams | ts.SourceFile, params: MappedFileParams): this;\n\n  addVirtualFiles(files: readonly ts.SourceFile[]): Promise<this>;\n\n  build(): ProgramContainer;\n}\n\nexport const programFactory = (params: ProgramFactoryParams): ProgramFactory => {\n  const vfsMap = new Map<string, string>();\n  const virtualMap: VirtualMap = new Map();\n\n  const system = createFSBackedSystem(vfsMap, params.rootPath, ts, resolveDefaultLibsPath(params));\n  const config = resolveConfig(params, system);\n\n  const rootNames = new Set(config.fileNames);\n  const options = {\n    ...ts.getDefaultCompilerOptions(),\n    getDefaultLibFilePath: ts.getDefaultLibFilePath(config.options),\n    ...config.options,\n  };\n  const host = createVirtualCompilerHost(system, options, ts);\n\n  const factory: ProgramFactory = {\n    get projectPath() {\n      return params.rootPath;\n    },\n\n    get projectDirectories() {\n      const directories = new Set([params.rootPath]);\n      for (const rootName of rootNames) directories.add(path.dirname(rootName));\n      return [...directories];\n    },\n\n    createSourceFile(params, scriptKind) {\n      return ts.createSourceFile(\n        params.fileId,\n        typeof params.sourceText === 'object'\n          ? params.sourceText.getText(0, params.sourceText.getLength())\n          : params.sourceText,\n        options.target || ts.ScriptTarget.ESNext,\n        /*setParentNodes*/ true,\n        scriptKind || (params.scriptKind != null ? params.scriptKind : ts.ScriptKind.TSX)\n      );\n    },\n\n    createExternalFiles(exts: readonly VirtualExtension[] = transformExtensions) {\n      const files: ts.SourceFile[] = [];\n      const seen = new Set(rootNames);\n      const directories = new Set([params.rootPath]);\n      for (const rootName of rootNames) directories.add(path.dirname(rootName));\n      for (const directory of directories) {\n        for (const fileId of system.readDirectory(directory, exts, ['**/node_modules'])) {\n          if (!seen.has(fileId)) {\n            seen.add(fileId);\n            const contents = system.readFile(fileId, 'utf8');\n            if (contents) {\n              files.push(\n                factory.createSourceFile(\n                  {\n                    fileId,\n                    sourceText: contents,\n                  },\n                  ts.ScriptKind.External\n                )\n              );\n            }\n          }\n        }\n      }\n      return files;\n    },\n\n    addSourceFile(input, addRootName) {\n      const sourceFile =\n        'fileName' in input ? input : factory.createSourceFile(input, ts.ScriptKind.TSX);\n      host.updateFile(sourceFile);\n      if (addRootName) rootNames.add(sourceFile.fileName);\n      return factory;\n    },\n\n    addMappedFile(input, params) {\n      const sourceFile =\n        'fileName' in input ? input : factory.createSourceFile(input, ts.ScriptKind.External);\n      if (params.mappings.length) rootNames.delete(sourceFile.fileName);\n      const sourceMappedFile = new SourceMappedFile(params.mappings, {\n        sourceFile,\n        sourceFileId: sourceFile.fileName,\n        generatedFileId: params.fileId,\n      });\n      virtualMap.set(sourceMappedFile.sourceFileId, sourceMappedFile);\n      virtualMap.set(sourceMappedFile.generatedFileId, sourceMappedFile);\n      return factory;\n    },\n\n    async addVirtualFiles(sourceFiles) {\n      for (const sourceFile of sourceFiles) {\n        const virtualFileId = `${sourceFile.fileName}.ts`;\n        const virtualCode = await transform(sourceFile);\n        if (virtualCode) {\n          factory\n            .addSourceFile(\n              {\n                fileId: virtualFileId,\n                sourceText: virtualCode.snapshot,\n              },\n              /*addRootName*/ true\n            )\n            .addMappedFile(sourceFile, {\n              mappings: virtualCode.mappings,\n              fileId: virtualFileId,\n            });\n        }\n      }\n      return factory;\n    },\n\n    build() {\n      // NOTE: This is necessary for `@0no-co/graphqlsp/api` to use the right instance\n      // of the typescript library\n      init({ typescript: ts });\n\n      return buildContainer({\n        virtualMap,\n        projectRoot: params.rootPath,\n        compilerHost: host.compilerHost,\n        rootNames: [...rootNames],\n        options,\n        system,\n      });\n    },\n  };\n\n  return factory;\n};\n\nconst resolveDefaultLibsPath = (params: ProgramFactoryParams): string => {\n  const target = ts.getDefaultLibFilePath({});\n  if (!ts.sys.fileExists(target)) {\n    const require = createRequire(params.configPath);\n    const request = 'typescript/package.json';\n    try {\n      return path.dirname(\n        require.resolve(request, {\n          paths: [\n            path.join(path.dirname(params.configPath), 'node_modules'),\n            path.join(params.rootPath, 'node_modules'),\n            ...(require.resolve.paths(request) || []),\n          ],\n        })\n      );\n    } catch (_error) {\n      return path.resolve(params.rootPath, 'node_modules', 'typescript', 'lib');\n    }\n  } else {\n    return path.dirname(target);\n  }\n};\n\nconst resolveConfig = (params: ProgramFactoryParams, system: ts.System): ts.ParsedCommandLine => {\n  const text = system.readFile(params.configPath, 'utf8') || '{}';\n  const parseResult = ts.parseConfigFileTextToJson(params.configPath, text);\n  if (parseResult.error != null) throw new Error(parseResult.error.messageText.toString());\n  const projectRoot = path.dirname(params.configPath);\n  return ts.parseJsonConfigFileContent(\n    parseResult.config,\n    system,\n    projectRoot,\n    ts.getDefaultCompilerOptions(),\n    params.configPath\n  );\n};\n","import type { WorkerOptions } from 'node:worker_threads';\nimport { Worker, isMainThread, parentPort, SHARE_ENV } from 'node:worker_threads';\n\nconst port = parentPort!;\nif (!isMainThread && !port) {\n  throw new ReferenceError('Failed to receive parent message port');\n}\n\nconst enum MainMessageCodes {\n  Start = 'START',\n  Close = 'CLOSE',\n  Pull = 'PULL',\n}\n\ninterface MainMessage {\n  id?: number;\n  kind: MainMessageCodes;\n  data?: any;\n}\n\nconst enum ThreadMessageCodes {\n  Next = 'NEXT',\n  Throw = 'THROW',\n  Return = 'RETURN',\n}\n\ninterface ThreadMessage {\n  id?: number;\n  kind: ThreadMessageCodes;\n  data?: any;\n}\n\nconst workerOpts: WorkerOptions = {\n  env: SHARE_ENV,\n  stderr: false,\n  stdout: false,\n  stdin: false,\n};\n\nconst asyncIteratorSymbol = (): typeof Symbol.asyncIterator =>\n  (typeof Symbol === 'function' && Symbol.asyncIterator) || ('@@asyncIterator' as any);\n\n/** Capture the stack above the caller */\nfunction captureStack(): NodeJS.CallSite[] {\n  const _error: any = new Error();\n  const _prepareStackTrace = Error.prepareStackTrace;\n  try {\n    let stack: NodeJS.CallSite[] | undefined;\n    Error.prepareStackTrace = (_error, _stack) => (stack = _stack);\n    Error.captureStackTrace(_error);\n    if (!_error.stack) throw _error;\n    return (stack && stack.slice(2)) || [];\n  } finally {\n    Error.prepareStackTrace = _prepareStackTrace;\n  }\n}\n\nexport interface Generator<Args extends readonly any[], Next> {\n  // TODO: Update to support for AsyncGenerator interface\n  (...args: Args): AsyncIterableIterator<Next>;\n}\n\nfunction main<Args extends readonly any[], Next>(url: string | URL): Generator<Args, Next> {\n  let worker: Worker;\n  let ids = 0;\n  return (...args: Args) => {\n    if (!worker) {\n      worker = new Worker(url, workerOpts);\n      worker.unref();\n    }\n\n    const id = ++ids | 0;\n    const buffer: ThreadMessage[] = [];\n\n    let started = false;\n    let ended = false;\n    let pulled = false;\n    let resolve: ((value: IteratorResult<Next>) => void) | void;\n    let reject: ((error: any) => void) | void;\n\n    function cleanup() {\n      ended = true;\n      resolve = undefined;\n      reject = undefined;\n      worker.removeListener('message', receiveMessage);\n      worker.removeListener('error', receiveError);\n    }\n\n    function sendMessage(kind: MainMessageCodes) {\n      worker.postMessage({ id, kind });\n    }\n\n    function receiveError(error: any) {\n      cleanup();\n      buffer.length = 1;\n      buffer[0] = {\n        id,\n        kind: ThreadMessageCodes.Throw,\n        data: error,\n      };\n    }\n\n    function receiveMessage(data: unknown) {\n      const message: ThreadMessage | null =\n        data && typeof data === 'object' && 'kind' in data ? (data as ThreadMessage) : null;\n      if (!message) {\n        return;\n      } else if (reject && message.kind === ThreadMessageCodes.Throw) {\n        reject(message.data);\n        cleanup();\n      } else if (resolve && message.kind === ThreadMessageCodes.Return) {\n        resolve({ done: true, value: message.data });\n        cleanup();\n      } else if (resolve && message.kind === ThreadMessageCodes.Next) {\n        pulled = false;\n        resolve({ done: false, value: message.data });\n      } else if (\n        message.kind === ThreadMessageCodes.Throw ||\n        message.kind === ThreadMessageCodes.Return\n      ) {\n        buffer.push(message);\n        cleanup();\n      } else if (message.kind === ThreadMessageCodes.Next) {\n        buffer.push(message);\n        pulled = false;\n      }\n    }\n\n    return {\n      async next() {\n        if (!started) {\n          started = true;\n          worker.addListener('message', receiveMessage);\n          worker.addListener('error', receiveError);\n          worker.postMessage({\n            id,\n            kind: MainMessageCodes.Start,\n            data: args,\n          });\n        }\n        if (ended && !buffer.length) {\n          return { done: true } as IteratorReturnResult<any>;\n        } else if (!ended && !pulled && buffer.length <= 1) {\n          pulled = true;\n          sendMessage(MainMessageCodes.Pull);\n        }\n        const message = buffer.shift();\n        if (message && message.kind === ThreadMessageCodes.Throw) {\n          cleanup();\n          throw message.data;\n        } else if (message && message.kind === ThreadMessageCodes.Return) {\n          cleanup();\n          return { value: message.data, done: true };\n        } else if (message && message.kind === ThreadMessageCodes.Next) {\n          return { value: message.data, done: false };\n        } else {\n          return new Promise((_resolve, _reject) => {\n            resolve = (value) => {\n              resolve = undefined;\n              reject = undefined;\n              _resolve(value);\n            };\n            reject = (error) => {\n              resolve = undefined;\n              reject = undefined;\n              _reject(error);\n            };\n          });\n        }\n      },\n      async return() {\n        if (!ended) {\n          cleanup();\n          sendMessage(MainMessageCodes.Close);\n        }\n        return { done: true } as IteratorReturnResult<any>;\n      },\n      [asyncIteratorSymbol()]() {\n        return this;\n      },\n    };\n  };\n}\n\nfunction thread<Args extends readonly any[], Next>(\n  message: MainMessage,\n  generator: Generator<Args, Next>\n): void {\n  if (message.kind !== MainMessageCodes.Start) return;\n  const id = message.id;\n  const iterator = generator(...(message.data as any));\n\n  let ended = false;\n  let pulled = false;\n  let looping = false;\n\n  function cleanup() {\n    ended = true;\n    port.removeListener('message', receiveMessage);\n  }\n\n  async function sendMessage(kind: ThreadMessageCodes, data?: any) {\n    try {\n      port.postMessage({ id, kind, data });\n    } catch (error) {\n      cleanup();\n      if (iterator.throw) {\n        let result = await iterator.throw();\n        if (result.done === false && iterator.return) {\n          result = await iterator.return();\n          sendMessage(ThreadMessageCodes.Return, result.value);\n        } else {\n          sendMessage(ThreadMessageCodes.Return, result.value);\n        }\n      } else {\n        sendMessage(ThreadMessageCodes.Return);\n      }\n    }\n  }\n\n  async function receiveMessage(data: unknown) {\n    const message: MainMessage | null =\n      data && typeof data === 'object' && 'kind' in data ? (data as MainMessage) : null;\n    let next: IteratorResult<Next>;\n    if (!message) {\n      return;\n    } else if (message.kind === MainMessageCodes.Close) {\n      cleanup();\n      if (iterator.return) iterator.return();\n    } else if (message.kind === MainMessageCodes.Pull && looping) {\n      pulled = true;\n    } else if (message.kind === MainMessageCodes.Pull) {\n      for (pulled = looping = true; pulled && !ended; ) {\n        try {\n          if ((next = await iterator.next()).done) {\n            cleanup();\n            if (iterator.return) next = await iterator.return();\n            sendMessage(ThreadMessageCodes.Return, next.value);\n          } else {\n            pulled = false;\n            sendMessage(ThreadMessageCodes.Next, next.value);\n          }\n        } catch (error) {\n          cleanup();\n          sendMessage(ThreadMessageCodes.Throw, error);\n        }\n      }\n      looping = false;\n    }\n  }\n\n  port.addListener('message', receiveMessage);\n}\n\nexport function expose<Args extends readonly any[], Return>(\n  generator: Generator<Args, Return>\n): Generator<Args, Return> {\n  if (isMainThread) {\n    const call = captureStack()[0];\n    const file = call && call.getFileName();\n    if (!file) throw new ReferenceError('Captured stack trace is empty');\n    const url = file.startsWith('file://') ? new URL(file) : file;\n    return main(url);\n  } else {\n    port.addListener('message', (data) => {\n      const message: MainMessage | null =\n        data && typeof data === 'object' && 'kind' in data ? (data as MainMessage) : null;\n      if (message) thread(message, generator);\n    });\n    return generator;\n  }\n}\n"],"names":["spanToFilePosition","file","span","output","fileName","line","col","endLine","undefined","endColumn","lineAndChar","getLineAndCharacterOfPosition","start","character","length","notImplemented","methodName","Error","defaultCompilerOptions","ts","getDefaultCompilerOptions","jsx","JsxEmit","React","strict","esModuleInterop","module","ModuleKind","ESNext","suppressOutputPathCheck","skipLibCheck","skipDefaultLibCheck","moduleResolution","ModuleResolutionKind","NodeJs","createVirtualCompilerHost","sys","compilerOptions","sourceFiles","Map","compilerHost","getCanonicalFileName","getDefaultLibFileName","getDirectories","getNewLine","newLine","getSourceFile","get","sourceFile","set","save","createSourceFile","readFile","target","useCaseSensitiveFileNames","updateFile","alreadyExists","has","writeFile","text","createVirtualLanguageServiceHost","rootFiles","customTransformers","fileNames","fileVersions","projectVersion","languageServiceHost","getProjectVersion","toString","getCompilationSettings","getCustomTransformers","getScriptFileNames","slice","getScriptSnapshot","contents","ScriptSnapshot","fromString","getScriptVersion","includes","push","Object","defineProperty","binarySearch_1","value","binarySearch","offsets","low","high","mid","Math","floor","midValue","max","min","track_1","getStack","track","resetOffsetStack","offsetStack","setTracking","tracking","stackOffset","segments","stacks","Proxy","prop","receiver","pop","shift","unshift","splice","sort","reverse","Reflect","items","stack","last","first","deleteCount","_stackStart","operateIndex","i","stackStart","originalLength","_deleteCount","compareFn","source","split","trim","endsWith","lastIndexOf","types","__createBinding","this","create","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","__exportStar","exports","p","prototype","hasOwnProperty","call","replaceRange","replaceSourceRange","replace","getLength","require$$0","require$$1","require$$2","segment","map","s","join","pattern","replacers","match","index","startOffset","endOffset","replacer","replaceAll","str","allMatch","matchAll","lengthDiff","_loop","newLength","newSegments","segmentStart","segmentEnd","inserts","trimSegmentEnd","newSegment","trimSegmentStart","combineStrings","indexOf","toOffsets","offset","startIndex","endIndex","endSegment","startSegmentStart","endSegmentStart","endSegmentEnd","trimEnd","trimStart","values","searchValue","translateOffset_1","translateOffset","fromOffsets","lengths","fromOffset","sourceMap","SourceMap","constructor","mappings","getSourceOffset","generatedOffset","mapped","findMatching","getGeneratedOffset","sourceOffset","getSourceOffsets","getGeneratedOffsets","fromRange","toRange","memo","getMemoBasedOnRange","end","skip","Set","mapping","add","sourceCodeOffsetsMemo","createMemo","generatedCodeOffsetsMemo","key","offsetsSet","a","b","buildMappings_1","buildMappings","chunks","sourceOffsets","generatedOffsets","data","buildStacks_1","buildStacks","result","range","require$$3","require$$4","SourceMappedFile","params","super","sourceFileId","generatedFileId","getSourceSpan","sourceStart","sourceEnd","maybeBind","that","fn","bind","buildLanguageService","virtualMap","languageService","createLanguageService","getProgram","mapFileFn","fileFn","fileId","args","mappedFile","mapFileTextSpanFn","textSpanFn","mapFileTextRangeFn","pos","mapFilePositionFn","positionFn","position","mapFileStartEndFn","program","assign","serviceProgram","projectRoot","isSourceFileFromExternalLibrary","getModeForResolutionAtIndex","getSourceFiles","mapSourceFileFn","getSyntacticDiagnostics","getSemanticDiagnostics","getDeclarationDiagnostics","isSourceFileDefaultLibrary","getModeForUsageLocation","path","relative","startsWith","buildProgram","getReferencesAtPosition","findReferences","getDefinitionAtPosition","getDefinitionAndBoundSpan","getTypeDefinitionAtPosition","getImplementationAtPosition","getCompletionsAtPosition","getCompletionEntryDetails","getCompletionEntrySymbol","getQuickInfoAtPosition","getBreakpointStatementAtPosition","getSignatureHelpItems","getRenameInfo","getSmartSelectionRange","getDocumentHighlights","prepareCallHierarchy","provideCallHierarchyIncomingCalls","provideCallHierarchyOutgoingCalls","getBraceMatchingAtPosition","getIndentationAtPosition","getFormattingEditsAfterKeystroke","getDocCommentTemplateAtPosition","isValidBraceCompletionAtPosition","getJsxClosingTagAtPosition","getLinkedEditingRangeAtPosition","getSpanOfEnclosingComment","getSyntacticClassifications","getSemanticClassifications","getEncodedSyntacticClassifications","getEncodedSemanticClassifications","provideInlayHints","getNameOrDottedNameSpan","getFormattingEditsForRange","getCodeFixesAtPosition","getFileReferences","getNavigationBarItems","getNavigationTree","getOutliningSpans","getTodoComments","getFormattingEditsForDocument","getEditsForRefactor","getEmitOutput","getSuggestionDiagnostics","getSupportedCodeFixes","toggleLineComment","toggleMultilineComment","commentSelection","uncommentSelection","buildPluginInfo","config","getLanguageService","system","rootNames","options","project","getProjectName","projectService","logger","console","serverHost","setImmediate","clearImmediate","_transformSvelte","_transformVue","transformExtensions","transform","extname","async","import","transformSvelte","transformVue","programFactory","vfsMap","createFSBackedSystem","files","_projectRoot","tsLibDirectory","root","nodeSys","tsLib","dirname","require","resolve","name","realpath","directory","createDirectory","directoryExists","Array","from","keys","some","exit","fileExists","tsLibName","getCurrentDirectory","getExecutingFilePath","readDirectory","libs","resolvePath","write","rootPath","resolveDefaultLibsPath","resolveConfig","getDefaultLibFilePath","host","factory","projectPath","projectDirectories","directories","rootName","scriptKind","sourceText","getText","ScriptTarget","ScriptKind","TSX","createExternalFiles","exts","seen","External","addSourceFile","input","addRootName","addMappedFile","delete","sourceMappedFile","addVirtualFiles","virtualFileId","virtualCode","snapshot","build","init","typescript","service","serviceHost","pluginInfo","getLanguageServiceHost","createProgram","getSourceMappedFile","getSourcePosition","buildContainer","createRequire","configPath","request","paths","_error","parseResult","parseConfigFileTextToJson","error","messageText","parseJsonConfigFileContent","port","parentPort","isMainThread","ReferenceError","MainMessageCodes","ThreadMessageCodes","workerOpts","env","SHARE_ENV","stderr","stdout","stdin","asyncIteratorSymbol","Symbol","asyncIterator","expose","generator","captureStack","_prepareStackTrace","prepareStackTrace","_stack","captureStackTrace","getFileName","main","url","worker","ids","Worker","unref","id","buffer","started","ended","pulled","reject","cleanup","removeListener","receiveMessage","receiveError","sendMessage","kind","postMessage","Throw","message","Return","done","Next","next","addListener","Start","Pull","Promise","_resolve","_reject","return","Close","URL","thread","iterator","looping","throw"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11]}