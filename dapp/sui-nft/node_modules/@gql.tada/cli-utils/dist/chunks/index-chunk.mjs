import e from "typescript";

import * as t from "node:path";

import { createRequire as r } from "node:module";

import { init as i } from "@0no-co/graphqlsp/api";

import { isMainThread as a, parentPort as n, Worker as o, SHARE_ENV as s } from "node:worker_threads";

var spanToFilePosition = (e, t) => {
  var r = {
    fileName: e.fileName,
    line: 1,
    col: 1,
    endLine: void 0,
    endColumn: void 0
  };
  var i = e.getLineAndCharacterOfPosition("number" == typeof t ? t : t.start);
  r.line = i.line + 1;
  r.col = i.character + 1;
  if ("number" != typeof t && t.length > 1) {
    i = e.getLineAndCharacterOfPosition(t.start + t.length - 1);
    r.endLine = i.line + 1;
    r.endColumn = i.character + 1;
  }
  return r;
};

/**!
 * The MIT License (MIT)
 * Copyright (c) Microsoft Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @see {@link https://github.com/microsoft/TypeScript-Website/blob/7f1c6e0577a0df9f945530a876ec87145a8b1fee/packages/typescript-vfs/src/index.ts}
 */ function notImplemented(e) {
  throw new Error(`Method '${e}' is not implemented.`);
}

var defaultCompilerOptions = e => ({
  ...e.getDefaultCompilerOptions(),
  jsx: e.JsxEmit.React,
  strict: !0,
  esModuleInterop: !0,
  module: e.ModuleKind.ESNext,
  suppressOutputPathCheck: !0,
  skipLibCheck: !0,
  skipDefaultLibCheck: !0,
  moduleResolution: e.ModuleResolutionKind.NodeJs
});

function createVirtualCompilerHost(e, t, r) {
  var i = new Map;
  return {
    compilerHost: {
      ...e,
      getCanonicalFileName: e => e,
      getDefaultLibFileName: () => "/" + r.getDefaultLibFileName(t),
      getDirectories: () => [],
      getNewLine: () => e.newLine,
      getSourceFile: a => i.get(a) || (e => {
        i.set(e.fileName, e);
        return e;
      })(r.createSourceFile(a, e.readFile(a), t.target || defaultCompilerOptions(r).target, !1)),
      useCaseSensitiveFileNames: () => e.useCaseSensitiveFileNames
    },
    updateFile: t => {
      var r = i.has(t.fileName);
      e.writeFile(t.fileName, t.text);
      i.set(t.fileName, t);
      return r;
    }
  };
}

function createVirtualLanguageServiceHost(e, t, r, i, a) {
  var n = [ ...t ];
  var {compilerHost: o, updateFile: s} = createVirtualCompilerHost(e, r, i);
  var l = new Map;
  var c = 0;
  return {
    languageServiceHost: {
      ...o,
      getProjectVersion: () => c.toString(),
      getCompilationSettings: () => r,
      getCustomTransformers: () => a,
      getScriptFileNames: () => n.slice(),
      getScriptSnapshot: t => {
        var r = e.readFile(t);
        if (r) {
          return i.ScriptSnapshot.fromString(r);
        }
        return;
      },
      getScriptVersion: e => l.get(e) || "0",
      writeFile: e.writeFile
    },
    updateFile: e => {
      c++;
      l.set(e.fileName, c.toString());
      if (!n.includes(e.fileName)) {
        n.push(e.fileName);
      }
      s(e);
    }
  };
}

var l = {};

var c = {};

var g = {};

Object.defineProperty(g, "__esModule", {
  value: !0
});

g.binarySearch = void 0;

g.binarySearch = function binarySearch$2(e, t) {
  var r = 0;
  var i = e.length - 1;
  while (r <= i) {
    var a = Math.floor((r + i) / 2);
    var n = e[a];
    if (n < t) {
      r = a + 1;
    } else if (n > t) {
      i = a - 1;
    } else {
      r = a;
      i = a;
      break;
    }
  }
  return Math.max(Math.min(r, i, e.length - 1), 0);
};

var f = {};

Object.defineProperty(f, "__esModule", {
  value: !0
});

f.getStack = f.track = f.resetOffsetStack = f.offsetStack = f.setTracking = void 0;

var u = !0;

var d = 0;

f.setTracking = function setTracking(e) {
  u = e;
};

f.offsetStack = function offsetStack() {
  d++;
};

f.resetOffsetStack = function resetOffsetStack() {
  d--;
};

f.track = function track(e, t = []) {
  return [ new Proxy(e, {
    get(e, t, r) {
      if (u) {
        if ("push" === t) {
          return push;
        }
        if ("pop" === t) {
          return pop;
        }
        if ("shift" === t) {
          return shift;
        }
        if ("unshift" === t) {
          return unshift;
        }
        if ("splice" === t) {
          return splice;
        }
        if ("sort" === t) {
          return sort;
        }
        if ("reverse" === t) {
          return reverse;
        }
      }
      return Reflect.get(e, t, r);
    }
  }), t ];
  function push(...r) {
    t.push({
      stack: getStack(),
      length: r.length
    });
    return e.push(...r);
  }
  function pop() {
    if (t.length) {
      var r = t[t.length - 1];
      if (r.length > 1) {
        r.length--;
      } else {
        t.pop();
      }
    }
    return e.pop();
  }
  function shift() {
    if (t.length) {
      var r = t[0];
      if (r.length > 1) {
        r.length--;
      } else {
        t.shift();
      }
    }
    return e.shift();
  }
  function unshift(...r) {
    t.unshift({
      stack: getStack(),
      length: r.length
    });
    return e.unshift(...r);
  }
  function splice(r, i, ...a) {
    if (void 0 === i) {
      i = e.length - r;
    }
    var n = 0;
    var o;
    for (var s = 0; s < t.length; s++) {
      var l = t[s];
      var c = n;
      n = c + l.length;
      if (r >= c) {
        o = s + 1;
        var g = l.length;
        l.length = r - c;
        t.splice(o, 0, {
          stack: l.stack,
          length: g - l.length
        });
        break;
      }
    }
    if (void 0 === o) {
      throw new Error("Invalid splice operation");
    }
    var f = i;
    for (var u = o; u < t.length; u++) {
      var d = t[u];
      while (f > 0 && d.length > 0) {
        d.length--;
        f--;
      }
      if (0 === f) {
        break;
      }
    }
    t.splice(o, 0, {
      stack: getStack(),
      length: a.length
    });
    return e.splice(r, i, ...a);
  }
  function sort(r) {
    t.splice(0, t.length, {
      stack: getStack(),
      length: e.length
    });
    return e.sort(r);
  }
  function reverse() {
    t.splice(0, t.length, {
      stack: getStack(),
      length: e.length
    });
    return e.reverse();
  }
};

function getStack() {
  var e = (new Error).stack.split("\n")[3 + d].trim();
  if (e.endsWith(")")) {
    e = e.slice(e.lastIndexOf("(") + 1, -1);
  } else {
    e = e.slice(e.lastIndexOf(" ") + 1);
  }
  return e;
}

f.getStack = getStack;

var p = {};

Object.defineProperty(p, "__esModule", {
  value: !0
});

!function(e) {
  var t = this && this.__createBinding || (Object.create ? function(e, t, r, i) {
    if (void 0 === i) {
      i = r;
    }
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (!a || ("get" in a ? !t.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      };
    }
    Object.defineProperty(e, i, a);
  } : function(e, t, r, i) {
    if (void 0 === i) {
      i = r;
    }
    e[i] = t[r];
  });
  var r = this && this.__exportStar || function(e, r) {
    for (var i in e) {
      if ("default" !== i && !Object.prototype.hasOwnProperty.call(r, i)) {
        t(r, e, i);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  e.replaceRange = e.replaceSourceRange = e.replaceAll = e.replace = e.create = e.toString = e.getLength = void 0;
  var i = g;
  var a = f;
  r(p, e);
  r(f, e);
  function getLength(e) {
    var t = 0;
    for (var r of e) {
      t += "string" == typeof r ? r.length : r[0].length;
    }
    return t;
  }
  e.getLength = getLength;
  function toString(e) {
    return e.map((e => "string" == typeof e ? e : e[0])).join("");
  }
  e.toString = toString;
  e.create = function create(e) {
    return [ [ e, void 0, 0 ] ];
  };
  e.replace = function replace(e, t, ...r) {
    var i = toString(e).match(t);
    if (i && void 0 !== i.index) {
      var n = i.index;
      var o = n + i[0].length;
      (0, a.offsetStack)();
      replaceRange(e, n, o, ...r.map((e => "function" == typeof e ? e(i[0]) : e)));
      (0, a.resetOffsetStack)();
    }
  };
  e.replaceAll = function replaceAll(e, t, ...r) {
    var i = toString(e);
    var n = i.matchAll(t);
    var o = i.length;
    var s = 0;
    var _loop = function(t) {
      if (void 0 !== t.index) {
        var i = t.index + s;
        var n = i + t[0].length;
        (0, a.offsetStack)();
        replaceRange(e, i, n, ...r.map((e => "function" == typeof e ? e(t[0]) : e)));
        (0, a.resetOffsetStack)();
        var l = getLength(e);
        s += l - o;
        o = l;
      }
    };
    for (var l of n) {
      _loop(l);
    }
  };
  e.replaceSourceRange = function replaceSourceRange(e, t, r, i, ...n) {
    for (var o of e) {
      if ("string" == typeof o) {
        continue;
      }
      if (o[1] === t) {
        var s = o[2];
        var l = o[2] + o[0].length;
        if (s <= r && l >= i) {
          var c = [];
          if (r > s) {
            c.push(trimSegmentEnd(o, r - s));
          }
          for (var g of n) {
            c.push(g);
          }
          if (i < l) {
            c.push(trimSegmentStart(o, i - l));
          }
          combineStrings(c);
          (0, a.offsetStack)();
          e.splice(e.indexOf(o), 1, ...c);
          (0, a.resetOffsetStack)();
          return !0;
        }
      }
    }
    return !1;
  };
  function replaceRange(e, t, r, ...n) {
    var o = function toOffsets(e) {
      var t = [];
      var r = 0;
      for (var i of e) {
        t.push(r);
        r += "string" == typeof i ? i.length : i[0].length;
      }
      return t;
    }(e);
    var s = (0, i.binarySearch)(o, t);
    var l = (0, i.binarySearch)(o, r);
    var c = e[l];
    var g = o[s];
    var f = o[l];
    var u = o[l] + ("string" == typeof c ? c.length : c[0].length);
    var d = [];
    if (t > g) {
      d.push(trimSegmentEnd(e[s], t - g));
    }
    for (var p of n) {
      d.push(p);
    }
    if (r < u) {
      d.push(trimSegmentStart(c, r - f));
    }
    combineStrings(d);
    (0, a.offsetStack)();
    e.splice(s, l - s + 1, ...d);
    (0, a.resetOffsetStack)();
  }
  e.replaceRange = replaceRange;
  function combineStrings(e) {
    for (var t = e.length - 1; t >= 1; t--) {
      if ("string" == typeof e[t] && "string" == typeof e[t - 1]) {
        e[t - 1] = e[t - 1] + e[t];
        (0, a.offsetStack)();
        e.splice(t, 1);
        (0, a.resetOffsetStack)();
      }
    }
  }
  function trimSegmentEnd(e, t) {
    if ("string" == typeof e) {
      return e.slice(0, t);
    }
    return [ e[0].slice(0, t), ...e.slice(1) ];
  }
  function trimSegmentStart(e, t) {
    if ("string" == typeof e) {
      return e.slice(t);
    }
    if (t < 0) {
      t += e[0].length;
    }
    return [ e[0].slice(t), e[1], e[2] + t, ...e.slice(3) ];
  }
}(c);

var v = {};

var m = {};

Object.defineProperty(m, "__esModule", {
  value: !0
});

m.binarySearch = void 0;

m.binarySearch = function binarySearch(e, t) {
  var r = 0;
  var i = e.length - 1;
  var a;
  while (r <= i) {
    var n = Math.floor((r + i) / 2);
    var o = e[n];
    if (o < t) {
      r = n + 1;
    } else if (o > t) {
      i = n - 1;
    } else {
      r = n;
      i = n;
      a = n;
      break;
    }
  }
  return {
    low: Math.max(Math.min(r, i, e.length - 1), 0),
    high: Math.min(Math.max(r, i, 0), e.length - 1),
    match: a
  };
};

var h = {};

Object.defineProperty(h, "__esModule", {
  value: !0
});

h.translateOffset = void 0;

h.translateOffset = function translateOffset(e, t, r, i) {
  for (var a = 0; a < t.length; a++) {
    var n = t[a];
    if (e >= n && e <= n + i[a]) {
      return r[a] + e - n;
    }
  }
};

Object.defineProperty(v, "__esModule", {
  value: !0
});

v.SourceMap = void 0;

var S = m;

var y = h;

v.SourceMap = class SourceMap {
  constructor(e) {
    this.mappings = e;
  }
  getSourceOffset(e) {
    for (var t of this.findMatching(e, "generatedOffsets", "sourceOffsets")) {
      return t;
    }
  }
  getGeneratedOffset(e) {
    for (var t of this.findMatching(e, "sourceOffsets", "generatedOffsets")) {
      return t;
    }
  }
  getSourceOffsets(e) {
    return this.findMatching(e, "generatedOffsets", "sourceOffsets");
  }
  getGeneratedOffsets(e) {
    return this.findMatching(e, "sourceOffsets", "generatedOffsets");
  }
  * findMatching(e, t, r) {
    var i = this.getMemoBasedOnRange(t);
    if (0 === i.offsets.length) {
      return;
    }
    var {low: a, high: n} = (0, S.binarySearch)(i.offsets, e);
    var o = new Set;
    for (var s = a; s <= n; s++) {
      for (var l of i.mappings[s]) {
        if (o.has(l)) {
          continue;
        }
        o.add(l);
        var c = (0, y.translateOffset)(e, l[t], l[r], l.lengths);
        if (void 0 !== c) {
          yield [ c, l ];
        }
      }
    }
  }
  getMemoBasedOnRange(e) {
    return "sourceOffsets" === e ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
  }
  createMemo(e) {
    var t = new Set;
    for (var r of this.mappings) {
      for (var i = 0; i < r[e].length; i++) {
        t.add(r[e][i]);
        t.add(r[e][i] + r.lengths[i]);
      }
    }
    var a = [ ...t ].sort(((e, t) => e - t));
    var n = a.map((() => new Set));
    for (var o of this.mappings) {
      for (var s = 0; s < o[e].length; s++) {
        var l = (0, S.binarySearch)(a, o[e][s]).match;
        var c = (0, S.binarySearch)(a, o[e][s] + o.lengths[s]).match;
        for (var g = l; g <= c; g++) {
          n[g].add(o);
        }
      }
    }
    return {
      offsets: a,
      mappings: n
    };
  }
};

var F = {};

Object.defineProperty(F, "__esModule", {
  value: !0
});

F.buildMappings = void 0;

F.buildMappings = function buildMappings(e) {
  var t = 0;
  var r = [];
  for (var i of e) {
    if ("string" == typeof i) {
      t += i.length;
    } else {
      r.push({
        source: i[1],
        sourceOffsets: [ i[2] ],
        generatedOffsets: [ t ],
        lengths: [ i[0].length ],
        data: i[3]
      });
      t += i[0].length;
    }
  }
  return r;
};

var k = {};

Object.defineProperty(k, "__esModule", {
  value: !0
});

k.buildStacks = void 0;

k.buildStacks = function buildStacks(e, t) {
  var r = 0;
  var i = 0;
  var a = [];
  for (var n of t) {
    var o = r;
    for (var s = 0; s < n.length; s++) {
      var l = e[i + s];
      if ("string" == typeof l) {
        r += l.length;
      } else {
        r += l[0].length;
      }
    }
    i += n.length;
    a.push({
      source: n.stack,
      range: [ o, r ]
    });
  }
  return a;
};

!function(e) {
  var t = this && this.__createBinding || (Object.create ? function(e, t, r, i) {
    if (void 0 === i) {
      i = r;
    }
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (!a || ("get" in a ? !t.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      };
    }
    Object.defineProperty(e, i, a);
  } : function(e, t, r, i) {
    if (void 0 === i) {
      i = r;
    }
    e[i] = t[r];
  });
  var r = this && this.__exportStar || function(e, r) {
    for (var i in e) {
      if ("default" !== i && !Object.prototype.hasOwnProperty.call(r, i)) {
        t(r, e, i);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  r(c, e);
  r(v, e);
  r(h, e);
  r(F, e);
  r(k, e);
}(l);

class SourceMappedFile extends l.SourceMap {
  constructor(e, t) {
    super(e);
    this.sourceFile = t.sourceFile;
    this.sourceFileId = t.sourceFileId;
    this.generatedFileId = t.generatedFileId;
  }
  getSourceSpan(e) {
    var t = this.getSourceOffset("number" == typeof e ? e : e.start);
    if (null != t) {
      var r = "number" != typeof e ? this.getSourceOffset(e.start + e.length - 1) : null;
      return {
        fileName: this.sourceFileId,
        start: t[0],
        length: null != r ? r[0] - t[0] + 1 : "number" != typeof e ? e.length : 1
      };
    } else {
      return {
        fileName: this.generatedFileId,
        start: "number" != typeof e ? e.start : e,
        length: "number" != typeof e ? e.length : 1
      };
    }
  }
}

function maybeBind(e, t) {
  return t ? t.bind(e) : t;
}

var buildLanguageService = r => {
  var {virtualMap: i} = r;
  var a = e.createLanguageService(r.languageServiceHost);
  var n = maybeBind(a, a.getProgram);
  var mapFileFn = e => (t, ...r) => {
    var n = i.get(t);
    if (n && n.sourceFileId === t) {
      t = n.generatedFileId;
    }
    return e.call(a, t, ...r);
  };
  var mapFileTextSpanFn = e => (t, r, ...n) => {
    var o = i.get(t);
    if (o && o.sourceFileId === t) {
      t = o.generatedFileId;
      var s = o.getGeneratedOffset(r.start)?.[0];
      var l = o.getGeneratedOffset(r.start + r.length - 1)?.[0];
      if (null != s) {
        r = {
          start: s,
          length: r.length
        };
        if (null != l) {
          r.length = l - s + 1;
        }
      }
    }
    return e.call(a, t, r, ...n);
  };
  var mapFileTextRangeFn = e => (t, r, ...n) => {
    var o = i.get(t);
    if (o && o.sourceFileId === t) {
      t = o.generatedFileId;
      var s = o.getGeneratedOffset(r.pos)?.[0];
      var l = o.getGeneratedOffset(r.end)?.[0];
      if (null != s) {
        r = {
          pos: s,
          end: s + (r.end - r.pos)
        };
        if (null != l) {
          r.end = l;
        }
      }
    }
    return e.call(a, t, r, ...n);
  };
  var mapFilePositionFn = e => (t, r, ...n) => {
    var o = i.get(t);
    if (o && o.sourceFileId === t) {
      t = o.generatedFileId;
      r = o.getGeneratedOffset(r)?.[0] ?? r;
    }
    return e.call(a, t, r, ...n);
  };
  var mapFileStartEndFn = e => (t, r, n, ...o) => {
    var s = i.get(t);
    if (s && s.sourceFileId === t) {
      t = s.generatedFileId;
      r = s.getGeneratedOffset(r)?.[0] ?? r;
      n = s.getGeneratedOffset(n)?.[0] ?? n;
    }
    return e.call(a, t, r, n, ...o);
  };
  var o;
  return Object.assign(a, {
    getProgram() {
      if (o) {
        return o;
      } else {
        var e = n();
        return e ? o = (e => {
          var {program: r, virtualMap: i, projectRoot: a} = e;
          var n = maybeBind(r, r.isSourceFileFromExternalLibrary);
          var o = maybeBind(r, r.getModeForResolutionAtIndex);
          var s = maybeBind(r, r.getSourceFile);
          var l = maybeBind(r, r.getSourceFiles);
          var mapSourceFileFn = e => (t, ...a) => {
            var n = t && i.get(t.fileName);
            if (n && n.sourceFileId === t?.fileName) {
              t = s(n.generatedFileId) || t;
            }
            return e.call(r, t, ...a);
          };
          return Object.assign(r, {
            getSyntacticDiagnostics: mapSourceFileFn(r.getSyntacticDiagnostics),
            getSemanticDiagnostics: mapSourceFileFn(r.getSemanticDiagnostics),
            getDeclarationDiagnostics: mapSourceFileFn(r.getDeclarationDiagnostics),
            isSourceFileDefaultLibrary: mapSourceFileFn(r.isSourceFileDefaultLibrary),
            getModeForUsageLocation: mapSourceFileFn(r.getModeForUsageLocation),
            isSourceFileFromExternalLibrary(e) {
              var t = i.get(e.fileName);
              return !(!t || t.sourceFileId !== e.fileName) || n(e);
            },
            getSourceFiles() {
              var e = [];
              for (var i of l()) {
                if (!t.relative(a, i.fileName).startsWith("..") && !r.isSourceFileFromExternalLibrary(i)) {
                  e.push(i);
                }
              }
              return e;
            },
            getSourceFile(e) {
              var t = i.get(e);
              if (t && t.sourceFileId === e) {
                e = t.generatedFileId;
              }
              return s(e);
            },
            getModeForResolutionAtIndex(e, t) {
              var r = i.get(e.fileName);
              if (r && r.sourceFileId === e.fileName) {
                e = s(r.generatedFileId) || e;
                t = r.getGeneratedOffset(t)?.[0] ?? t;
              }
              return o(e, t);
            }
          });
        })({
          program: e,
          virtualMap: r.virtualMap,
          projectRoot: r.projectRoot
        }) : void 0;
      }
    },
    getReferencesAtPosition: mapFilePositionFn(a.getReferencesAtPosition),
    findReferences: mapFilePositionFn(a.findReferences),
    getDefinitionAtPosition: mapFilePositionFn(a.getDefinitionAtPosition),
    getDefinitionAndBoundSpan: mapFilePositionFn(a.getDefinitionAndBoundSpan),
    getTypeDefinitionAtPosition: mapFilePositionFn(a.getTypeDefinitionAtPosition),
    getImplementationAtPosition: mapFilePositionFn(a.getImplementationAtPosition),
    getCompletionsAtPosition: mapFilePositionFn(a.getCompletionsAtPosition),
    getCompletionEntryDetails: mapFilePositionFn(a.getCompletionEntryDetails),
    getCompletionEntrySymbol: mapFilePositionFn(a.getCompletionEntrySymbol),
    getQuickInfoAtPosition: mapFilePositionFn(a.getQuickInfoAtPosition),
    getBreakpointStatementAtPosition: mapFilePositionFn(a.getBreakpointStatementAtPosition),
    getSignatureHelpItems: mapFilePositionFn(a.getSignatureHelpItems),
    getRenameInfo: mapFilePositionFn(a.getRenameInfo),
    getSmartSelectionRange: mapFilePositionFn(a.getSmartSelectionRange),
    getDocumentHighlights: mapFilePositionFn(a.getDocumentHighlights),
    prepareCallHierarchy: mapFilePositionFn(a.prepareCallHierarchy),
    provideCallHierarchyIncomingCalls: mapFilePositionFn(a.provideCallHierarchyIncomingCalls),
    provideCallHierarchyOutgoingCalls: mapFilePositionFn(a.provideCallHierarchyOutgoingCalls),
    getBraceMatchingAtPosition: mapFilePositionFn(a.getBraceMatchingAtPosition),
    getIndentationAtPosition: mapFilePositionFn(a.getIndentationAtPosition),
    getFormattingEditsAfterKeystroke: mapFilePositionFn(a.getFormattingEditsAfterKeystroke),
    getDocCommentTemplateAtPosition: mapFilePositionFn(a.getDocCommentTemplateAtPosition),
    isValidBraceCompletionAtPosition: mapFilePositionFn(a.isValidBraceCompletionAtPosition),
    getJsxClosingTagAtPosition: mapFilePositionFn(a.getJsxClosingTagAtPosition),
    getLinkedEditingRangeAtPosition: mapFilePositionFn(a.getLinkedEditingRangeAtPosition),
    getSpanOfEnclosingComment: mapFilePositionFn(a.getSpanOfEnclosingComment),
    getSyntacticClassifications: mapFileTextSpanFn(a.getSyntacticClassifications),
    getSemanticClassifications: mapFileTextSpanFn(a.getSemanticClassifications),
    getEncodedSyntacticClassifications: mapFileTextSpanFn(a.getEncodedSyntacticClassifications),
    getEncodedSemanticClassifications: mapFileTextSpanFn(a.getEncodedSemanticClassifications),
    provideInlayHints: mapFileTextSpanFn(a.provideInlayHints),
    getNameOrDottedNameSpan: mapFileStartEndFn(a.getNameOrDottedNameSpan),
    getFormattingEditsForRange: mapFileStartEndFn(a.getFormattingEditsForRange),
    getCodeFixesAtPosition: mapFileStartEndFn(a.getCodeFixesAtPosition),
    getFileReferences: mapFileFn(a.getFileReferences),
    getNavigationBarItems: mapFileFn(a.getNavigationBarItems),
    getNavigationTree: mapFileFn(a.getNavigationTree),
    getOutliningSpans: mapFileFn(a.getOutliningSpans),
    getTodoComments: mapFileFn(a.getTodoComments),
    getFormattingEditsForDocument: mapFileFn(a.getFormattingEditsForDocument),
    getEditsForRefactor: mapFileFn(a.getEditsForRefactor),
    getEmitOutput: mapFileFn(a.getEmitOutput),
    getSuggestionDiagnostics: mapFileFn(a.getSuggestionDiagnostics),
    getSemanticDiagnostics: mapFileFn(a.getSemanticDiagnostics),
    getSyntacticDiagnostics: mapFileFn(a.getSyntacticDiagnostics),
    getSupportedCodeFixes: mapFileFn(a.getSupportedCodeFixes),
    toggleLineComment: mapFileTextRangeFn(a.toggleLineComment),
    toggleMultilineComment: mapFileTextRangeFn(a.toggleMultilineComment),
    commentSelection: mapFileTextRangeFn(a.commentSelection),
    uncommentSelection: mapFileTextRangeFn(a.uncommentSelection)
  });
};

var buildPluginInfo = t => {
  var r;
  return {
    config: t.config,
    get languageService() {
      return t.getLanguageService();
    },
    get languageServiceHost() {
      return r || (r = createVirtualLanguageServiceHost(t.system, [ ...t.rootNames ], t.options, e).languageServiceHost);
    },
    project: {
      getProjectName: () => t.projectRoot,
      projectService: {
        logger: console
      }
    },
    serverHost: {
      ...t.system,
      setImmediate,
      clearImmediate
    }
  };
};

var b;

var M;

var O = [ ".svelte", ".vue" ];

var transform = e => {
  var r = t.extname(e.fileName);
  if (".svelte" === r) {
    return (async (...e) => {
      if (!b) {
        b = (await import("./svelte-chunk.mjs")).transform;
      }
      return b(...e);
    })(e);
  } else if (".vue" === r) {
    return (async (...e) => {
      if (!M) {
        M = (await import("./vue-chunk.mjs")).transform;
      }
      return M(...e);
    })(e);
  } else {
    throw new Error(`Tried transforming unknown file type "${r}". Supported: ${O.join(", ")}`);
  }
};

var programFactory = r => {
  var a = new Map;
  var n = new Map;
  var o = function createFSBackedSystem(e, r, i, a) {
    var n = r + "/vfs";
    var o = i.sys;
    var s = a ?? t.dirname(require.resolve("typescript"));
    return {
      name: "fs-vfs",
      root: n,
      args: [],
      realpath: e => {
        if (o.realpath) {
          return o.realpath(e);
        }
        return e;
      },
      createDirectory: () => notImplemented("createDirectory"),
      directoryExists: t => Array.from(e.keys()).some((e => e.startsWith(t))) || o.directoryExists(t),
      exit: o.exit,
      fileExists: t => {
        if (e.has(t)) {
          return !0;
        }
        if (t.includes("tsconfig.json") || t.includes("tsconfig.json")) {
          return !1;
        }
        if (t.startsWith("/lib")) {
          var r = `${s}/${t.replace("/", "")}`;
          return o.fileExists(r);
        }
        return o.fileExists(t);
      },
      getCurrentDirectory: () => n,
      getDirectories: o.getDirectories,
      getExecutingFilePath: () => notImplemented("getExecutingFilePath"),
      readDirectory: (...t) => {
        if ("/" === t[0]) {
          return Array.from(e.keys());
        } else {
          return o.readDirectory(...t);
        }
      },
      readFile: t => {
        if (e.has(t)) {
          return e.get(t);
        }
        if (t.startsWith("/lib")) {
          var r = `${s}/${t.replace("/", "")}`;
          var i = o.readFile(r);
          if (!i) {
            var a = o.readDirectory(s);
            throw new Error(`TSVFS: A request was made for ${r} but there wasn't a file found in the file map. You likely have a mismatch in the compiler options for the CDN download vs the compiler program. Existing Libs: ${a}.`);
          }
          return i;
        }
        return o.readFile(t);
      },
      resolvePath: t => {
        if (e.has(t)) {
          return t;
        }
        return o.resolvePath(t);
      },
      newLine: "\n",
      useCaseSensitiveFileNames: !0,
      write: () => notImplemented("write"),
      writeFile: (t, r) => {
        e.set(t, r);
      }
    };
  }(a, r.rootPath, e, resolveDefaultLibsPath(r));
  var s = resolveConfig(r, o);
  var l = new Set(s.fileNames);
  var c = {
    ...e.getDefaultCompilerOptions(),
    getDefaultLibFilePath: e.getDefaultLibFilePath(s.options),
    ...s.options
  };
  var g = createVirtualCompilerHost(o, c, e);
  var f = {
    get projectPath() {
      return r.rootPath;
    },
    get projectDirectories() {
      var e = new Set([ r.rootPath ]);
      for (var i of l) {
        e.add(t.dirname(i));
      }
      return [ ...e ];
    },
    createSourceFile: (t, r) => e.createSourceFile(t.fileId, "object" == typeof t.sourceText ? t.sourceText.getText(0, t.sourceText.getLength()) : t.sourceText, c.target || e.ScriptTarget.ESNext, !0, r || (null != t.scriptKind ? t.scriptKind : e.ScriptKind.TSX)),
    createExternalFiles(i = O) {
      var a = [];
      var n = new Set(l);
      var s = new Set([ r.rootPath ]);
      for (var c of l) {
        s.add(t.dirname(c));
      }
      for (var g of s) {
        for (var u of o.readDirectory(g, i, [ "**/node_modules" ])) {
          if (!n.has(u)) {
            n.add(u);
            var d = o.readFile(u, "utf8");
            if (d) {
              a.push(f.createSourceFile({
                fileId: u,
                sourceText: d
              }, e.ScriptKind.External));
            }
          }
        }
      }
      return a;
    },
    addSourceFile(t, r) {
      var i = "fileName" in t ? t : f.createSourceFile(t, e.ScriptKind.TSX);
      g.updateFile(i);
      if (r) {
        l.add(i.fileName);
      }
      return f;
    },
    addMappedFile(t, r) {
      var i = "fileName" in t ? t : f.createSourceFile(t, e.ScriptKind.External);
      if (r.mappings.length) {
        l.delete(i.fileName);
      }
      var a = new SourceMappedFile(r.mappings, {
        sourceFile: i,
        sourceFileId: i.fileName,
        generatedFileId: r.fileId
      });
      n.set(a.sourceFileId, a);
      n.set(a.generatedFileId, a);
      return f;
    },
    async addVirtualFiles(e) {
      for (var t of e) {
        var r = `${t.fileName}.ts`;
        var i = await transform(t);
        if (i) {
          f.addSourceFile({
            fileId: r,
            sourceText: i.snapshot
          }, !0).addMappedFile(t, {
            mappings: i.mappings,
            fileId: r
          });
        }
      }
      return f;
    },
    build() {
      i({
        typescript: e
      });
      return (t => {
        var r;
        var i;
        var a;
        var n;
        var getLanguageServiceHost = () => a || (a = createVirtualLanguageServiceHost(t.system, [ ...t.rootNames ], t.options, e).languageServiceHost);
        var getLanguageService = () => i || (i = buildLanguageService({
          system: t.system,
          rootNames: t.rootNames,
          virtualMap: t.virtualMap,
          options: t.options,
          projectRoot: t.projectRoot,
          languageServiceHost: getLanguageServiceHost()
        }));
        var getProgram = () => {
          if (!r) {
            r = getLanguageService().getProgram() || e.createProgram({
              rootNames: t.rootNames,
              options: t.options,
              host: t.compilerHost
            });
          }
          return r;
        };
        return {
          get program() {
            return getProgram();
          },
          get languageService() {
            return getLanguageService();
          },
          buildPluginInfo: e => n || (n = buildPluginInfo({
            getLanguageService,
            getLanguageServiceHost,
            projectRoot: t.projectRoot,
            rootNames: t.rootNames,
            system: t.system,
            options: t.options,
            config: e
          })),
          getSourceFile: e => getProgram().getSourceFile(e),
          getSourceFiles: () => getProgram().getSourceFiles(),
          getSourceMappedFile: e => t.virtualMap.get("string" != typeof e ? e.fileName : e),
          getSourceSpan(e, r) {
            var i = "string" != typeof e ? e.fileName : e;
            var a = t.virtualMap.get(i);
            return a ? a.getSourceSpan(r) : {
              fileName: i,
              start: "number" != typeof r ? r.start : r,
              length: "number" != typeof r ? r.length : 1
            };
          },
          getSourcePosition(e, r) {
            var i = t.virtualMap.get("string" != typeof e ? e.fileName : e);
            if (i) {
              var a = i.getSourceSpan(r);
              if (a.fileName === i.sourceFileId) {
                return spanToFilePosition(i.sourceFile, a);
              }
            }
            return spanToFilePosition("string" == typeof e ? getProgram().getSourceFile(e) : e, r);
          }
        };
      })({
        virtualMap: n,
        projectRoot: r.rootPath,
        compilerHost: g.compilerHost,
        rootNames: [ ...l ],
        options: c,
        system: o
      });
    }
  };
  return f;
};

var resolveDefaultLibsPath = i => {
  var a = e.getDefaultLibFilePath({});
  if (!e.sys.fileExists(a)) {
    var n = r(i.configPath);
    var o = "typescript/package.json";
    try {
      return t.dirname(n.resolve(o, {
        paths: [ t.join(t.dirname(i.configPath), "node_modules"), t.join(i.rootPath, "node_modules"), ...n.resolve.paths(o) || [] ]
      }));
    } catch (e) {
      return t.resolve(i.rootPath, "node_modules", "typescript", "lib");
    }
  } else {
    return t.dirname(a);
  }
};

var resolveConfig = (r, i) => {
  var a = i.readFile(r.configPath, "utf8") || "{}";
  var n = e.parseConfigFileTextToJson(r.configPath, a);
  if (null != n.error) {
    throw new Error(n.error.messageText.toString());
  }
  var o = t.dirname(r.configPath);
  return e.parseJsonConfigFileContent(n.config, i, o, e.getDefaultCompilerOptions(), r.configPath);
};

var P = n;

if (!a && !P) {
  throw new ReferenceError("Failed to receive parent message port");
}

var w = function(e) {
  e.Start = "START";
  e.Close = "CLOSE";
  e.Pull = "PULL";
  return e;
}(w || {});

var C = function(e) {
  e.Next = "NEXT";
  e.Throw = "THROW";
  e.Return = "RETURN";
  return e;
}(C || {});

var N = {
  env: s,
  stderr: !1,
  stdout: !1,
  stdin: !1
};

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

function expose(e) {
  if (a) {
    var t = function captureStack() {
      var e = new Error;
      var t = Error.prepareStackTrace;
      try {
        var r;
        Error.prepareStackTrace = (e, t) => r = t;
        Error.captureStackTrace(e);
        if (!e.stack) {
          throw e;
        }
        return r && r.slice(2) || [];
      } finally {
        Error.prepareStackTrace = t;
      }
    }()[0];
    var r = t && t.getFileName();
    if (!r) {
      throw new ReferenceError("Captured stack trace is empty");
    }
    return function main(e) {
      var t;
      var r = 0;
      return (...i) => {
        if (!t) {
          (t = new o(e, N)).unref();
        }
        var a = 0 | ++r;
        var n = [];
        var s = !1;
        var l = !1;
        var c = !1;
        var g;
        var f;
        function cleanup() {
          l = !0;
          g = void 0;
          f = void 0;
          t.removeListener("message", receiveMessage);
          t.removeListener("error", receiveError);
        }
        function sendMessage(e) {
          t.postMessage({
            id: a,
            kind: e
          });
        }
        function receiveError(e) {
          cleanup();
          n.length = 1;
          n[0] = {
            id: a,
            kind: C.Throw,
            data: e
          };
        }
        function receiveMessage(e) {
          var t = e && "object" == typeof e && "kind" in e ? e : null;
          if (!t) {
            return;
          } else if (f && t.kind === C.Throw) {
            f(t.data);
            cleanup();
          } else if (g && t.kind === C.Return) {
            g({
              done: !0,
              value: t.data
            });
            cleanup();
          } else if (g && t.kind === C.Next) {
            c = !1;
            g({
              done: !1,
              value: t.data
            });
          } else if (t.kind === C.Throw || t.kind === C.Return) {
            n.push(t);
            cleanup();
          } else if (t.kind === C.Next) {
            n.push(t);
            c = !1;
          }
        }
        return {
          async next() {
            if (!s) {
              s = !0;
              t.addListener("message", receiveMessage);
              t.addListener("error", receiveError);
              t.postMessage({
                id: a,
                kind: w.Start,
                data: i
              });
            }
            if (l && !n.length) {
              return {
                done: !0
              };
            } else if (!l && !c && n.length <= 1) {
              c = !0;
              sendMessage(w.Pull);
            }
            var e = n.shift();
            if (e && e.kind === C.Throw) {
              cleanup();
              throw e.data;
            } else if (e && e.kind === C.Return) {
              cleanup();
              return {
                value: e.data,
                done: !0
              };
            } else if (e && e.kind === C.Next) {
              return {
                value: e.data,
                done: !1
              };
            } else {
              return new Promise(((e, t) => {
                g = t => {
                  g = void 0;
                  f = void 0;
                  e(t);
                };
                f = e => {
                  g = void 0;
                  f = void 0;
                  t(e);
                };
              }));
            }
          },
          async return() {
            if (!l) {
              cleanup();
              sendMessage(w.Close);
            }
            return {
              done: !0
            };
          },
          [asyncIteratorSymbol()]() {
            return this;
          }
        };
      };
    }(r.startsWith("file://") ? new URL(r) : r);
  } else {
    P.addListener("message", (t => {
      var r = t && "object" == typeof t && "kind" in t ? t : null;
      if (r) {
        !function thread(e, t) {
          if (e.kind !== w.Start) {
            return;
          }
          var r = e.id;
          var i = t(...e.data);
          var a = !1;
          var n = !1;
          var o = !1;
          function cleanup() {
            a = !0;
            P.removeListener("message", receiveMessage);
          }
          async function sendMessage(e, t) {
            try {
              P.postMessage({
                id: r,
                kind: e,
                data: t
              });
            } catch (e) {
              cleanup();
              if (i.throw) {
                var a = await i.throw();
                if (!1 === a.done && i.return) {
                  a = await i.return();
                  sendMessage(C.Return, a.value);
                } else {
                  sendMessage(C.Return, a.value);
                }
              } else {
                sendMessage(C.Return);
              }
            }
          }
          async function receiveMessage(e) {
            var t = e && "object" == typeof e && "kind" in e ? e : null;
            var r;
            if (!t) {
              return;
            } else if (t.kind === w.Close) {
              cleanup();
              if (i.return) {
                i.return();
              }
            } else if (t.kind === w.Pull && o) {
              n = !0;
            } else if (t.kind === w.Pull) {
              for (n = o = !0; n && !a; ) {
                try {
                  if ((r = await i.next()).done) {
                    cleanup();
                    if (i.return) {
                      r = await i.return();
                    }
                    sendMessage(C.Return, r.value);
                  } else {
                    n = !1;
                    sendMessage(C.Next, r.value);
                  }
                } catch (e) {
                  cleanup();
                  sendMessage(C.Throw, e);
                }
              }
              o = !1;
            }
          }
          P.addListener("message", receiveMessage);
        }(r, e);
      }
    }));
    return e;
  }
}

export { expose as e, programFactory as p };
//# sourceMappingURL=index-chunk.mjs.map
